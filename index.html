<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ±‰å­—æ¦«å¯ç”Ÿæˆå™¨ V5.1 (ç»ˆæä¿®å¤ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/SVGLoader.js"></script>
    <!-- Three.js 3D è£…é…é¢„è§ˆ -->
    <style>
        html, body { margin: 0; padding: 0; height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background-color: #f3f4f6; }
        body { display: flex; overflow: hidden; }
        .slider { width: 100%; height: 6px; border-radius: 3px; background: #d1d5db; outline: none; -webkit-appearance: none; appearance: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #4f46e5; cursor: pointer; border: none; box-shadow: 0 1px 3px rgba(0,0,0,0.3);}
        #paperCanvas { border: 1px solid #e5e7eb; background: #ffffff; border-radius: 0.5rem; width: 100%; height: 100%; display: block; }
        .section-title { font-weight: 600; color: #374151; margin-top: 12px; margin-bottom: 8px; font-size: 14px; border-left: 4px solid #4f46e5; padding-left: 8px;}
        details summary { cursor: pointer; list-style: none; }
        details summary::-webkit-details-marker { display: none; }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex bg-gray-100 text-gray-800 font-sans m-0 p-0">
    
    <aside class="w-80 flex-shrink-0 bg-white border-r border-gray-200 shadow-xl z-20 flex flex-col h-full">
        
        <div class="px-5 py-4 border-b border-gray-200 bg-gray-50">
            <h1 class="text-xl font-bold text-gray-800">æ±‰å­—æ¦«å¯ç”Ÿæˆå™¨ V5.2</h1>
            <p class="text-xs text-gray-500 mt-1">Uå‹æ‰¿æ‰˜åº•åº§ | ç¬”ç”»å»¶ç”Ÿ</p>
        </div>

        <div class="flex-1 overflow-y-auto pb-6">
            
            <details class="group border-b border-gray-100" open>
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-gray-50 transition-colors">
                    <span class="font-bold text-sm text-gray-700">1. åŸºç¡€è®¾ç½®</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-4 pt-1">
                    <label class="block text-xs font-medium text-gray-600 mb-1">è½½å…¥å­—ä½“ (.ttf, .otf)</label>
                    <input type="file" id="fontFile" accept=".ttf,.otf" class="block w-full text-xs text-gray-500 file:mr-3 file:py-1.5 file:px-3 file:rounded-md file:border-0 file:text-xs file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 mb-3">
                    
                    <label class="block text-xs font-medium text-gray-600 mb-1">è¾“å…¥æ±‰å­—ï¼ˆå•ä¸ªï¼‰</label>
                    <input type="text" id="hanziInput" value="ç¦" maxlength="1" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 text-xl text-center font-bold">
                </div>
            </details>

            <details class="group border-b border-gray-100" open>
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-gray-50 transition-colors">
                    <span class="font-bold text-sm text-gray-700">2. å¤–è§‚å°ºå¯¸å‚æ•°</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-4 pt-1 space-y-3">
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>åŸºå‡†å®½åº¦ W:</span> <span class="text-indigo-600"><input type="number" id="widthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="50" max="300" value="120" step="1"> mm</span></label>
                        <input type="range" id="widthSlider" min="50" max="300" value="120" step="1" class="slider">
                        <p id="heightHint" class="text-xs text-gray-500 mt-0.5">å½“å‰æ¨¡å‹å®é™…æ€»é«˜åº¦ H: çº¦ â€” mm</p>
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>æ€»æ·±åº¦ D (å«ä¾§æ¿):</span> <span class="text-indigo-600"><input type="number" id="depthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="20" max="200" value="60" step="1"> mm</span></label>
                        <input type="range" id="depthSlider" min="20" max="200" value="60" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>ææ–™åšåº¦ T:</span> <span class="text-indigo-600"><input type="number" id="thicknessValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="1" max="10" value="3" step="0.1"> mm</span></label>
                        <input type="range" id="thicknessSlider" min="1" max="10" value="3" step="0.1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>ä¾§æ¿é«˜åº¦ H2:</span> <span class="text-indigo-600"><input type="number" id="sidePanelHeightValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="20" max="200" value="50" step="1"> mm</span></label>
                        <input type="range" id="sidePanelHeightSlider" min="20" max="200" value="50" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>ä¸»é¢æ¿æ’å£å®½åº¦:</span> <span class="text-indigo-600"><input type="number" id="mainTenonWidthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="5" max="50" value="10" step="1"> mm</span></label>
                        <input type="range" id="mainTenonWidthSlider" min="5" max="50" value="10" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>ä¾§æ¿æ’å£å®½åº¦:</span> <span class="text-indigo-600"><input type="number" id="sideTenonWidthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="5" max="50" value="10" step="1"> mm</span></label>
                        <input type="range" id="sideTenonWidthSlider" min="5" max="50" value="10" step="1" class="slider">
                    </div>
                    <hr class="border-dashed border-gray-200 my-2">
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>å‰²ç¼è¡¥å¿ (ä¸¥ä¸åˆç¼):</span> <span class="text-indigo-600"><input type="number" id="kerfValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="-0.5" max="0.5" value="0.10" step="0.01"> mm</span></label>
                        <input type="range" id="kerfSlider" min="-0.5" max="0.5" value="0.10" step="0.01" class="slider">
                    </div>
                </div>
            </details>

            <details class="group border-b border-gray-100" open>
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-gray-50 transition-colors">
                    <span class="font-bold text-sm text-gray-700">3. å†…éƒ¨éª¨æ¶è°ƒèŠ‚</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-4 pt-1 space-y-3">
                    <div class="p-2 bg-gray-50 rounded-md border border-gray-200 mb-2">
                        <label class="block text-xs font-bold text-gray-700 mb-1">æ”¯æ’‘ç»“æ„ç±»å‹ï¼š</label>
                        <div class="flex gap-3 mt-1">
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="radio" name="baseType" value="dual" checked class="text-indigo-600">
                                <span class="ml-1 text-xs text-gray-600">åŒæ§½ (å¦‚:ç¦)</span>
                            </label>
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="radio" name="baseType" value="single" class="text-indigo-600">
                                <span class="ml-1 text-xs text-gray-600">å•æ§½ (å¦‚:å¹¸)</span>
                            </label>
                        </div>
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>éª¨æ¶æ°´å¹³é—´è· (å·¦å³):</span> <span class="text-indigo-600"><input type="number" id="innerXSpacingValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="20" max="200" value="60" step="1"> mm</span></label>
                        <input type="range" id="innerXSpacingSlider" min="20" max="200" value="60" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>åº•åº§æŠ¬å‡é«˜åº¦ (è·åº•éƒ¨):</span> <span class="text-indigo-600"><input type="number" id="innerYSpacingValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="20" max="200" value="60" step="1"> mm</span></label>
                        <input type="range" id="innerYSpacingSlider" min="20" max="200" value="60" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>æ•´ä½“ X è½´å¹³ç§»:</span> <span class="text-indigo-600"><input type="number" id="offsetXValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="-100" max="100" value="0" step="1"> mm</span></label>
                        <input type="range" id="offsetXSlider" min="-100" max="100" value="0" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>æ•´ä½“ Y è½´å¹³ç§»:</span> <span class="text-indigo-600"><input type="number" id="offsetYValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="-100" max="100" value="0" step="1"> mm</span></label>
                        <input type="range" id="offsetYSlider" min="-100" max="100" value="0" step="1" class="slider">
                    </div>
                </div>
            </details>

            <details class="group border-b border-gray-100">
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-indigo-50 transition-colors">
                    <span class="font-bold text-sm text-indigo-700">4. è‡ªåŠ¨é˜²æ‰å­—å¤„ç†</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-4 pt-1 space-y-3">
                    <label class="inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="autoBridgeEnabledCheckbox" checked class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                        <span class="ml-2 text-sm font-medium text-gray-700">å¼€å¯è‡ªåŠ¨è¿ç­‹</span>
                    </label>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>è¿ç­‹å®½åº¦:</span> <span class="text-indigo-600"><input type="number" id="autoBridgeWidthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="1" max="10" value="3" step="0.5"> mm</span></label>
                        <input type="range" id="autoBridgeWidthSlider" min="1" max="10" value="3" step="0.5" class="slider">
                    </div>
                </div>
            </details>

            <details class="group border-b border-gray-100">
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-purple-50 transition-colors">
                    <span class="font-bold text-sm text-purple-700">5. 3D æè´¨ä¸æ¸²æŸ“</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-4 pt-1 space-y-3">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">é€‰æ‹©ææ–™è´¨æ„Ÿ:</label>
                        <select id="materialSelect" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm">
                            <option value="default" selected>âšª é»˜è®¤ç™½æ¨¡ (ç”¨äºæ£€æŸ¥ç»“æ„)</option>
                            <option value="wood">ğŸªµ åŸæœ¨æ¿æ (æ¸©æš–è‡ªç„¶)</option>
                            <option value="acrylic">ğŸŸ¥ çº¢è‰²äºšå…‹åŠ› (åŠé€æ˜)</option>
                            <option value="metal">ğŸ”© æ‹‰ä¸é‡‘å± (é“åˆé‡‘)</option>
                        </select>
                    </div>
                    <p class="text-xs text-gray-400 mt-2 leading-tight">æ³¨ï¼šæè´¨ä»…ä¾›é¢„è§ˆå‚è€ƒï¼Œå®é™…æ•ˆæœå–å†³äºç‰©ç†åŠ å·¥ã€‚</p>
                </div>
            </details>

        </div>

        <div class="p-4 border-t border-gray-200 bg-white shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)] z-10 space-y-2">
            <button id="exportBtn" class="w-full bg-indigo-600 text-white py-3 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 font-bold shadow-md transition-all">
                â†“ ä¸‹è½½ SVG åˆ‡å‰²å›¾çº¸
            </button>
            <button id="resetDefaultsBtn" type="button" class="w-full bg-gray-200 text-gray-700 py-2.5 px-4 rounded-lg hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 text-sm font-medium transition-all">
                æ¢å¤é»˜è®¤è®¾ç½®
            </button>
        </div>
    </aside>

    <main class="flex-1 flex flex-col h-full min-w-0 relative">
        <div class="flex border-b border-gray-200 bg-white px-4 pt-4 flex-shrink-0">
            <button id="tab2D" class="tab-btn active mr-2 px-6 py-2.5 font-bold text-sm rounded-t-lg bg-indigo-50 text-indigo-700 border-t border-l border-r border-indigo-100">2D å›¾çº¸è§†å›¾</button>
            <button id="tab3D" class="tab-btn inactive px-6 py-2.5 font-medium text-sm rounded-t-lg bg-gray-100 text-gray-500 hover:bg-gray-200">3D è£…é…é¢„è§ˆ</button>
        </div>

        <div class="flex-1 relative w-full h-full bg-gray-100">
            <div id="view2DContainer" class="absolute inset-0 w-full h-full flex flex-col">
                <div class="p-2 bg-white border-b flex justify-between items-center px-6 flex-shrink-0 shadow-sm z-10">
                    <div class="text-xs font-medium text-gray-600">
                        <span class="inline-block w-3 h-3 bg-red-500 rounded-full mr-1 align-middle"></span> çº¢è‰²ä¸ºæ¿€å…‰åˆ‡å‰²çº¿
                        <span class="inline-block w-3 h-3 bg-blue-500 rounded-full ml-4 mr-1 align-middle"></span> <span class="text-blue-600">è“è‰²ä¸ºæœªåˆ‡é€æç¤º(éœ€è°ƒèŠ‚æ»‘å—å¯¹å‡†)</span>
                    </div>
                </div>
                <div class="flex-1 w-full h-full relative overflow-hidden bg-white">
                    <canvas id="paperCanvas" resize="true" class="absolute inset-0 w-full h-full outline-none"></canvas>
                </div>
            </div>

            <div id="view3DContainer" class="absolute inset-0 w-full h-full flex flex-col hidden">
                <div class="p-2 bg-white border-b flex justify-between items-center px-6 flex-shrink-0 shadow-sm z-10">
                    <div class="text-xs font-medium text-gray-600">
                        ğŸ–±ï¸ é¼ æ ‡å·¦é”®æ—‹è½¬è§†å›¾ | ğŸ–±ï¸ é¼ æ ‡å³é”®å¹³ç§» | ğŸ–±ï¸ æ»šè½®ç¼©æ”¾
                    </div>
                </div>
                <div id="threeContainer" class="flex-1 w-full h-full outline-none bg-gray-100"></div>
            </div>
        </div>
    </main>

    <script>
        // åŠ¨æ€åŠ è½½è„šæœ¬ï¼ˆæ”¯æŒå¤šä¸ªå¤‡ç”¨ CDNï¼‰
        function loadScript(urls, onSuccess, onError, retryCount = 0) {
            if (retryCount >= urls.length) {
                onError();
                return;
            }

            const script = document.createElement('script');
            script.src = urls[retryCount];
            script.onload = () => {
                console.log('æˆåŠŸåŠ è½½:', urls[retryCount]);
                onSuccess();
            };
            script.onerror = () => {
                console.warn('åŠ è½½å¤±è´¥:', urls[retryCount], 'å°è¯•ä¸‹ä¸€ä¸ª...');
                loadScript(urls, onSuccess, onError, retryCount + 1);
            };
            document.head.appendChild(script);
        }

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        function showError(message) {
            const canvas = document.getElementById('paperCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ef4444';
                ctx.font = '18px Arial';
                ctx.fillText(message, 20, 50);
                ctx.fillText('è¯·å°è¯•ï¼š1) åˆ·æ–°é¡µé¢ 2) æ£€æŸ¥æµè§ˆå™¨éšç§è®¾ç½®', 20, 80);
                ctx.fillText('3) ä½¿ç”¨å…¶ä»–æµè§ˆå™¨ 4) æ£€æŸ¥ç½‘ç»œè¿æ¥', 20, 110);
            }
        }

        // åŠ è½½ opentype.jsï¼ˆå¤šä¸ªå¤‡ç”¨ CDNï¼‰
        const opentypeUrls = [
            'https://unpkg.com/opentype.js@1.3.4/dist/opentype.min.js',
            'https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js'
        ];

        // åŠ è½½ paper.jsï¼ˆå¤šä¸ªå¤‡ç”¨ CDNï¼‰
        const paperUrls = [
            'https://unpkg.com/paper@0.12.17/dist/paper-full.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/paper/0.12.17/paper-full.min.js',
            'https://cdn.jsdelivr.net/npm/paper@0.12.17/dist/paper-full.min.js'
        ];

        let opentypeLoaded = false;
        let paperLoaded = false;

        // åŠ è½½ opentype.js
        loadScript(
            opentypeUrls,
            () => {
                opentypeLoaded = true;
                checkAllLoaded();
            },
            () => {
                console.error('æ‰€æœ‰ opentype.js CDN éƒ½åŠ è½½å¤±è´¥');
                showError('opentype.js åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æµè§ˆå™¨è®¾ç½®');
            }
        );

        // åŠ è½½ paper.js
        loadScript(
            paperUrls,
            () => {
                paperLoaded = true;
                checkAllLoaded();
            },
            () => {
                console.error('æ‰€æœ‰ paper.js CDN éƒ½åŠ è½½å¤±è´¥');
                showError('paper.js åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æµè§ˆå™¨è®¾ç½®');
            }
        );

        // æ£€æŸ¥æ‰€æœ‰åº“æ˜¯å¦åŠ è½½å®Œæˆ
        function checkAllLoaded() {
            if (opentypeLoaded && paperLoaded && typeof opentype !== 'undefined' && typeof paper !== 'undefined') {
                console.log('æ‰€æœ‰åº“åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–');
                initializeApp();
                setTimeout(() => {
                    if (typeof paper !== 'undefined') {
                        render();
                    }
                }, 150);
            }
        }

        // ç­‰å¾…æ‰€æœ‰è„šæœ¬åŠ è½½å®Œæˆï¼ˆå¤‡ç”¨æ£€æŸ¥ï¼‰
        function waitForLibraries(callback) {
            const checkInterval = setInterval(() => {
                if (typeof paper !== 'undefined' && typeof opentype !== 'undefined') {
                    clearInterval(checkInterval);
                    callback();
                }
            }, 50);
            
            // 15ç§’è¶…æ—¶
            setTimeout(() => {
                clearInterval(checkInterval);
                if (typeof paper === 'undefined' || typeof opentype === 'undefined') {
                    console.error('åº“åŠ è½½è¶…æ—¶');
                    showError('è„šæœ¬åŠ è½½è¶…æ—¶ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®');
                }
            }, 15000);
        }

        let currentFont = null;
        let currentHanzi = 'ç¦';
        let W = 120; let H = 120; let D = 60; let T = 3;
        let sidePanelHeight = 50; // é»˜è®¤ä¾§æ¿é«˜åº¦
        let mainTenonWidth = 10;
        let sideTenonWidth = 10;
        let kerf = 0.10;
        let innerXSpacing = 60; let innerYSpacing = 60;
        let offsetX = 0; let offsetY = 0;
        let scale = 2; // SVG æ˜¾ç¤ºç¼©æ”¾æ¯”ä¾‹ (1mm = 2px)
        
        // è‡ªåŠ¨é˜²æ‰å­—ï¼ˆStencil åŒ–ï¼‰å‚æ•°
        let autoBridgeEnabled = true;   // å¼€å¯è‡ªåŠ¨è¿ç­‹
        let autoBridgeWidth = 3;         // è¿ç­‹å®½åº¦ mm
        
        let baseSupportType = 'dual'; // 'dual' è¡¨ç¤ºåŒè„šï¼Œ'single' è¡¨ç¤ºå•è„š
        
        let scene3DInited = false; // 3D åœºæ™¯æ˜¯å¦å·²åˆå§‹åŒ–
        let renderGeneration = 0; // ç”¨äºé˜²æ­¢å¼‚æ­¥æ¨¡å‹é‡å 
        let woodMaterialInstance = null; // æœ¨ææè´¨å•ä¾‹
        let selectedMaterialType = 'default'; // é»˜è®¤æè´¨
        
        // è®¡ç®—åçš„é›¶ä»¶æ•°æ®ï¼ˆç”¨äº3Dæ¸²æŸ“ï¼‰
        let computedParts = {
            front: null,
            back: null,
            sideL: null,
            sideR: null,
            bottom: null
        };
        
        function resetComputedParts() {
            computedParts = {
                front: null,
                back: null,
                sideL: null,
                sideR: null,
                bottom: null
            };
        }

        const UI = {
            fontFile: document.getElementById('fontFile'),
            hanziInput: document.getElementById('hanziInput'),
            canvas: document.getElementById('paperCanvas'),
            exportBtn: document.getElementById('exportBtn')
        };

        // åˆå§‹åŒ–å‡½æ•°ï¼ˆåœ¨åº“åŠ è½½å®Œæˆåæ‰§è¡Œï¼‰
        function initializeApp() {
            paper.setup(UI.canvas); // ç¡®ä¿æœ€å…ˆåˆå§‹åŒ–ç”»å¸ƒ

            // ç»‘å®šæ‰€æœ‰æ»‘å—äº‹ä»¶çš„å¿«æ·å‡½æ•°ï¼ˆä½¿ç”¨å›è°ƒå‡½æ•°æ›´æ–°å˜é‡ï¼‰
            const bindSlider = (id, setter) => {
                const slider = document.getElementById(id + 'Slider');
                const valInput = document.getElementById(id + 'Value');
                if (!slider || !valInput) {
                    console.warn(`æ‰¾ä¸åˆ°æ»‘å—å…ƒç´ : ${id}Slider æˆ– ${id}Value`);
                    return;
                }
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                const step = parseFloat(slider.step);

                function clampToBounds(val) {
                    const n = parseFloat(val);
                    if (isNaN(n)) return parseFloat(slider.value);
                    return Math.min(max, Math.max(min, n));
                }
                function roundToStep(val) {
                    if (step <= 0) return val;
                    return Math.round(val / step) * step;
                }
                function applyAndRender(val) {
                    val = clampToBounds(val);
                    val = Math.min(max, Math.max(min, roundToStep(val)));
                    slider.value = val;
                    valInput.value = val;
                    setter(val);
                    render();
                }

                slider.addEventListener('input', () => {
                    valInput.value = slider.value;
                    setter(parseFloat(slider.value));
                    render();
                });
                valInput.addEventListener('input', () => {
                    const parsed = parseFloat(valInput.value);
                    if (isNaN(parsed)) return;
                    const safe = Math.min(max, Math.max(min, parsed));
                    slider.value = safe;
                    setter(safe);
                    render();
                });
                valInput.addEventListener('blur', () => {
                    applyAndRender(valInput.value);
                });
                valInput.addEventListener('change', () => {
                    applyAndRender(valInput.value);
                });

                valInput.value = slider.value;
            };

            bindSlider('width', (val) => { W = val; });
            bindSlider('depth', (val) => { D = val; });
            bindSlider('thickness', (val) => { T = val; });
            bindSlider('sidePanelHeight', (val) => { sidePanelHeight = val; });
            bindSlider('mainTenonWidth', (val) => { mainTenonWidth = val; });
            bindSlider('sideTenonWidth', (val) => { sideTenonWidth = val; });
            bindSlider('kerf', (val) => { kerf = val; });
            bindSlider('innerXSpacing', (val) => { innerXSpacing = val; });
            bindSlider('innerYSpacing', (val) => { innerYSpacing = val; });
            bindSlider('offsetX', (val) => { offsetX = val; });
            bindSlider('offsetY', (val) => { offsetY = val; });

            bindSlider('autoBridgeWidth', (val) => { autoBridgeWidth = val; });

            const autoBridgeCheckbox = document.getElementById('autoBridgeEnabledCheckbox');
            if (autoBridgeCheckbox) {
                autoBridgeCheckbox.addEventListener('change', function() {
                    autoBridgeEnabled = this.checked;
                    render();
                });
            }

            const radioButtons = document.querySelectorAll('input[name="baseType"]');
            radioButtons.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    baseSupportType = e.target.value;
                    render();
                });
            });

            const view2DContainer = document.getElementById('view2DContainer');
            const view3DContainer = document.getElementById('view3DContainer');
            const tab2D = document.getElementById('tab2D');
            const tab3D = document.getElementById('tab3D');
            if (tab2D && tab3D && view2DContainer && view3DContainer) {
                tab2D.addEventListener('click', function() {
                    view2DContainer.classList.remove('hidden');
                    view3DContainer.classList.add('hidden');
                    tab2D.classList.add('active', 'font-bold', 'bg-indigo-50', 'text-indigo-700', 'border-indigo-100');
                    tab2D.classList.remove('font-medium', 'bg-gray-100', 'text-gray-500');
                    tab3D.classList.remove('active', 'font-bold', 'bg-indigo-50', 'text-indigo-700', 'border-indigo-100');
                    tab3D.classList.add('font-medium', 'bg-gray-100', 'text-gray-500');
                });
                tab3D.addEventListener('click', function() {
                    view3DContainer.classList.remove('hidden');
                    view2DContainer.classList.add('hidden');
                    tab3D.classList.add('active', 'font-bold', 'bg-indigo-50', 'text-indigo-700', 'border-indigo-100');
                    tab3D.classList.remove('font-medium', 'bg-gray-100', 'text-gray-500');
                    tab2D.classList.remove('active', 'font-bold', 'bg-indigo-50', 'text-indigo-700', 'border-indigo-100');
                    tab2D.classList.add('font-medium', 'bg-gray-100', 'text-gray-500');
                    if (typeof scene3DInited === 'undefined' || !scene3DInited) {
                        if (typeof init3D === 'function') init3D();
                        scene3DInited = true;
                    }
                    if (typeof update3DModel === 'function') update3DModel();
                });
            }

            UI.fontFile.addEventListener('change', async (e) => {
                if (!e.target.files[0]) return;
                try {
                    const arrayBuffer = await e.target.files[0].arrayBuffer();
                    currentFont = opentype.parse(arrayBuffer);
                    currentHanzi = UI.hanziInput.value || 'ç¦';
                    render();
                } catch (err) {
                    alert('å­—ä½“åŠ è½½å¤±è´¥: ' + err.message);
                }
            });

            UI.hanziInput.addEventListener('input', (e) => {
                currentHanzi = e.target.value || 'ç¦';
                render();
            });

            UI.exportBtn.addEventListener('click', () => {
                if (!currentFont) return alert('è¯·å…ˆä¸Šä¼ å­—ä½“');
                const panels = window.exportPanels;
                if (!panels || !panels.front) return alert('è¯·å…ˆç”Ÿæˆå›¾çº¸ï¼ˆæ¸²æŸ“ä¸€æ¬¡åå†å¯¼å‡ºï¼‰');

                const gap = 10;
                const f = panels.front, b = panels.back, l = panels.left, r = panels.right, bot = panels.bottom;
                const fB = f.bounds, bB = b.bounds, lB = l.bounds, rB = r.bounds, botB = bot.bounds;

                function pathToSvgPaths(item) {
                    try {
                        const el = item.exportSVG({ asString: false });
                        if (!el) return '';
                        const pathEls = el.tagName && el.tagName.toLowerCase() === 'path' ? [el] : (el.querySelectorAll ? Array.from(el.querySelectorAll('path')) : []);
                        return pathEls.map(p => {
                            const d = p.getAttribute('d');
                            return d ? `<path d="${d.replace(/"/g, '&quot;')}" stroke-width="0.001" fill="none" stroke="#000"/>` : '';
                        }).filter(Boolean).join('');
                    } catch (e) { return ''; }
                }

                const row0H = Math.max(fB.height, bB.height);
                const row1Y = row0H + gap;
                const row1H = Math.max(lB.height, rB.height);
                const row2Y = row1Y + row1H + gap;

                const totalW = Math.max(fB.width + gap + bB.width, lB.width + gap + rB.width, botB.width);
                const totalH = row2Y + botB.height;

                const svgPaths = [
                    `<g transform="translate(${-fB.left}, ${-fB.top})">${pathToSvgPaths(f)}</g>`,
                    `<g transform="translate(${fB.width + gap - bB.left}, ${-bB.top})">${pathToSvgPaths(b)}</g>`,
                    `<g transform="translate(${-lB.left}, ${row1Y - lB.top})">${pathToSvgPaths(l)}</g>`,
                    `<g transform="translate(${lB.width + gap - rB.left}, ${row1Y - rB.top})">${pathToSvgPaths(r)}</g>`,
                    `<g transform="translate(${-botB.left}, ${row2Y - botB.top})">${pathToSvgPaths(bot)}</g>`
                ].join('\n');

                const svgString = '<?xml version="1.0" encoding="utf-8"?>\n' +
                    '<svg xmlns="http://www.w3.org/2000/svg" ' +
                    `width="${totalW}mm" height="${totalH}mm" ` +
                    `viewBox="0 0 ${totalW} ${totalH}">\n` +
                    svgPaths + '\n</svg>';

                const blob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `HanziBox_${currentHanzi}_T${T}_MainW${mainTenonWidth}_SideW${sideTenonWidth}_Kerf${kerf}.svg`;
                a.click();
                URL.revokeObjectURL(url);
            });

            const materialSelect = document.getElementById('materialSelect');
            if (materialSelect) {
                materialSelect.addEventListener('change', (e) => {
                    selectedMaterialType = e.target.value;
                    render();
                });
            }

            const resetDefaultsBtn = document.getElementById('resetDefaultsBtn');
            if (resetDefaultsBtn) {
                    resetDefaultsBtn.addEventListener('click', () => {
                        const defaults = {
                            width: 120, depth: 60, thickness: 3, sidePanelHeight: 50,
                            mainTenonWidth: 10, sideTenonWidth: 10, kerf: 0.10,
                            innerXSpacing: 60, innerYSpacing: 60, offsetX: 0, offsetY: 0,
                            autoBridgeWidth: 3
                        };
                        W = defaults.width;
                        D = defaults.depth;
                        T = defaults.thickness;
                        sidePanelHeight = defaults.sidePanelHeight;
                        mainTenonWidth = defaults.mainTenonWidth;
                        sideTenonWidth = defaults.sideTenonWidth;
                        kerf = defaults.kerf;
                        innerXSpacing = defaults.innerXSpacing;
                        innerYSpacing = defaults.innerYSpacing;
                        offsetX = defaults.offsetX;
                        offsetY = defaults.offsetY;
                        autoBridgeWidth = defaults.autoBridgeWidth;
                        const autoCb = document.getElementById('autoBridgeEnabledCheckbox');
                        if (autoCb) autoCb.checked = true;
                        autoBridgeEnabled = true;
                        const sl = document.getElementById('autoBridgeWidthSlider');
                        const v = document.getElementById('autoBridgeWidthValue');
                        if (sl) sl.value = String(defaults.autoBridgeWidth);
                        if (v) v.value = String(defaults.autoBridgeWidth);
                        for (const [id, val] of Object.entries(defaults)) {
                            if (id === 'autoBridgeWidth') continue;
                            const sl = document.getElementById(id + 'Slider');
                            const v = document.getElementById(id + 'Value');
                            if (sl) sl.value = String(val);
                            if (v) v.value = String(val);
                        }
                        render();
                    });
            }

            // è‡ªåŠ¨åŠ è½½é€»è¾‘ï¼ˆç›´æ¥æ”¾åœ¨ setup ä¹‹åï¼Œä½¿ç”¨ç»å¯¹è·¯å¾„é¿å… Vercel è·¯ç”±é—®é¢˜ï¼‰
            const showCanvasMsg = (txt, color = '#4f46e5') => {
                paper.project.clear();
                new paper.PointText({
                    point: paper.view.center,
                    content: txt,
                    fillColor: color,
                    fontSize: 18,
                    justification: 'center'
                });
                paper.view.draw();
            };

            showCanvasMsg('æ­£åœ¨ä»äº‘ç«¯è°ƒæ‹¨å­—ä½“é›¶ä»¶ (font.otf)...');

            const fontUrl = new URL('font.otf', window.location.href).href;
            fetch(fontUrl)
                .then(res => {
                    if (!res.ok) throw new Error('çŠ¶æ€ç : ' + res.status);
                    return res.arrayBuffer();
                })
                .then(buf => {
                    currentFont = opentype.parse(buf);
                    console.log('å­—ä½“è£…è½½æˆåŠŸ');
                    render(); // ç«‹å³æ‰§è¡Œåˆæ¬¡æ¸²æŸ“
                })
                .catch(err => {
                    console.error('åŠ è½½å¤±è´¥:', err);
                    showCanvasMsg('å­—ä½“é›¶ä»¶ä¸¢å¤± (404)ï¼Œè¯·æ£€æŸ¥ GitHub ä»“åº“ä¸­æ˜¯å¦å­˜åœ¨ font.otf', '#ef4444');
                });
        }

        // ã€åšå¦‚ç£çŸ³çš„å­—ä½“è§£æå¼•æ“ã€‘
        function convertToPaperPath(otPath) {
            console.log('å¼€å§‹è½¬æ¢è·¯å¾„...');
            try {
                // æ–¹æ³•1: ç›´æ¥ä½¿ç”¨ toPathData() åˆ›å»º SVG è·¯å¾„ï¼ˆæœ€å¯é ï¼‰
                try {
                    const pathData = otPath.toPathData(2);
                    console.log('toPathData() æˆåŠŸï¼Œè·¯å¾„æ•°æ®é•¿åº¦:', pathData ? pathData.length : 0);
                    
                    if (pathData && pathData.trim()) {
                        // åˆ›å»º SVG å…ƒç´ 
                        const svgNS = 'http://www.w3.org/2000/svg';
                        const svg = document.createElementNS(svgNS, 'svg');
                        svg.setAttribute('xmlns', svgNS);
                        const path = document.createElementNS(svgNS, 'path');
                        path.setAttribute('d', pathData);
                        svg.appendChild(path);
                        
                        console.log('å°è¯•å¯¼å…¥ SVG...');
                        // ä½¿ç”¨ SVG å¯¼å…¥ï¼Œå®ƒä¼šè‡ªåŠ¨å¤„ç†å¤šä¸ªæ–­å¼€çš„ç¬”ç”»ï¼ˆå¤šä¸ª M å‘½ä»¤ï¼‰å¹¶åˆ›å»º CompoundPath
                        let imported = paper.project.importSVG(svg, { insert: false });
                        console.log('å¯¼å…¥ç»“æœç±»å‹:', imported ? imported.constructor.name : 'null');
                        
                        if (imported) {
                            let paperPath = extractPathFromImported(imported);
                            if (paperPath) {
                                console.log('æˆåŠŸæå–è·¯å¾„ï¼Œç±»å‹:', paperPath.constructor.name, 'æ®µæ•°:', paperPath.segments ? paperPath.segments.length : 0);
                                // --- ä¿®æ­£ï¼šç§»é™¤ Y è½´ç¿»è½¬ï¼Œè§£å†³æ±‰å­—å€’ç«‹é—®é¢˜ ---
                                // try {
                                //     paperPath.scale(1, -1);
                                //     console.log('Yè½´ç¿»è½¬æˆåŠŸ');
                                // } catch (e) {
                                //     console.warn('ç¿»è½¬ Y è½´å¤±è´¥:', e);
                                // }
                                // -----------------------------------------
                                return paperPath;
                            } else {
                                console.warn('æå–è·¯å¾„å¤±è´¥');
                            }
                        } else {
                            console.warn('SVG å¯¼å…¥è¿”å› null');
                        }
                    } else {
                        console.warn('è·¯å¾„æ•°æ®ä¸ºç©º');
                    }
                } catch (e) {
                    console.warn('æ–¹æ³•1å¤±è´¥:', e);
                }
                
                // æ–¹æ³•2: ä½¿ç”¨ toSVG() ç„¶åè§£æ
                try {
                    const svgString = otPath.toSVG(2);
                    console.log('toSVG() æˆåŠŸï¼Œå­—ç¬¦ä¸²é•¿åº¦:', svgString ? svgString.length : 0);
                    
                    if (svgString) {
                        // å°è¯•æå–è·¯å¾„æ•°æ®
                        const pathMatch = svgString.match(/d=["']([^"']*)["']/);
                        if (pathMatch && pathMatch[1]) {
                            const pathData = pathMatch[1].trim();
                            console.log('æå–åˆ°è·¯å¾„æ•°æ®ï¼Œé•¿åº¦:', pathData.length);
                            
                            if (pathData) {
                                const svgNS = 'http://www.w3.org/2000/svg';
                                const svg = document.createElementNS(svgNS, 'svg');
                                svg.setAttribute('xmlns', svgNS);
                                const path = document.createElementNS(svgNS, 'path');
                                path.setAttribute('d', pathData);
                                svg.appendChild(path);
                                
                                let imported = paper.project.importSVG(svg, { insert: false });
                                if (imported) {
                                    let paperPath = extractPathFromImported(imported);
                                    if (paperPath) {
                                        // --- ä¿®æ­£ï¼šç§»é™¤ Y è½´ç¿»è½¬ ---
                                        // try {
                                        //     paperPath.scale(1, -1);
                                        // } catch (e) {
                                        //     console.warn('ç¿»è½¬ Y è½´å¤±è´¥:', e);
                                        // }
                                        // ---------------------------
                                        return paperPath;
                                    }
                                }
                            }
                        } else {
                            // å¦‚æœåŒ…å«å®Œæ•´çš„ SVGï¼Œå°è¯•ç›´æ¥è§£æ
                            if (svgString.includes('<svg') || svgString.includes('<path')) {
                                try {
                                    const parser = new DOMParser();
                                    const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
                                    const svgElement = svgDoc.documentElement;
                                    
                                    // æ£€æŸ¥è§£æé”™è¯¯
                                    const parserError = svgDoc.querySelector('parsererror');
                                    if (parserError) {
                                        console.warn('SVG è§£æé”™è¯¯:', parserError.textContent);
                                    } else {
                                        let imported = paper.project.importSVG(svgElement, { insert: false });
                                        if (imported) {
                                            let paperPath = extractPathFromImported(imported);
                                            if (paperPath) {
                                                // --- ä¿®æ­£ï¼šç§»é™¤ Y è½´ç¿»è½¬ ---
                                                // try {
                                                //     paperPath.scale(1, -1);
                                                // } catch (e) {
                                                //     console.warn('ç¿»è½¬ Y è½´å¤±è´¥:', e);
                                                // }
                                                // ---------------------------
                                                return paperPath;
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.warn('DOMParser å¤±è´¥:', e);
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.warn('æ–¹æ³•2å¤±è´¥:', e);
                }
                
                // æ–¹æ³•3: ç›´æ¥ä» opentype.js çš„ commands åˆ›å»º Paper.js è·¯å¾„
                // (æ–¹æ³•3æœ¬èº«çš„é€»è¾‘ä¸éœ€è¦ç¿»è½¬ï¼Œä¿æŒåŸæ ·)
                try {
                    console.log('å°è¯•æ–¹æ³•3: ç›´æ¥ä» commands åˆ›å»ºè·¯å¾„');
                    const commands = otPath.commands;
                    if (commands && commands.length > 0) {
                        console.log('æ‰¾åˆ°', commands.length, 'ä¸ªå‘½ä»¤');
                        
                        // åˆ›å»ºæ–°çš„ Paper.js è·¯å¾„
                        const paperPath = new paper.Path();
                        let currentX = 0, currentY = 0;
                        
                        for (let i = 0; i < commands.length; i++) {
                            const cmd = commands[i];
                            try {
                                if (cmd.type === 'M' || cmd.type === 'm') {
                                    // MoveTo
                                    currentX = cmd.type === 'M' ? cmd.x : currentX + cmd.x;
                                    currentY = cmd.type === 'M' ? -cmd.y : currentY - cmd.y;
                                    if (paperPath.segments.length === 0) {
                                        paperPath.moveTo(currentX, currentY);
                                    } else {
                                        paperPath.add(new paper.Point(currentX, currentY));
                                    }
                                } else if (cmd.type === 'L' || cmd.type === 'l') {
                                    // LineTo
                                    currentX = cmd.type === 'L' ? cmd.x : currentX + cmd.x;
                                    currentY = cmd.type === 'L' ? -cmd.y : currentY - cmd.y;
                                    paperPath.add(new paper.Point(currentX, currentY));
                                } else if (cmd.type === 'C' || cmd.type === 'c') {
                                    // Cubic Bezier
                                    const x1 = cmd.type === 'C' ? cmd.x1 : currentX + cmd.x1;
                                    const y1 = cmd.type === 'C' ? -cmd.y1 : currentY - cmd.y1;
                                    const x2 = cmd.type === 'C' ? cmd.x2 : currentX + cmd.x2;
                                    const y2 = cmd.type === 'C' ? -cmd.y2 : currentY - cmd.y2;
                                    currentX = cmd.type === 'C' ? cmd.x : currentX + cmd.x;
                                    currentY = cmd.type === 'C' ? -cmd.y : currentY - cmd.y;
                                    const handleIn = new paper.Point(x1, y1);
                                    const handleOut = new paper.Point(x2, y2);
                                    paperPath.add(new paper.Segment(new paper.Point(currentX, currentY), handleIn, handleOut));
                                } else if (cmd.type === 'Q' || cmd.type === 'q') {
                                    // Quadratic Bezier (è½¬æ¢ä¸ºä¸‰æ¬¡è´å¡å°”)
                                    const x1 = cmd.type === 'Q' ? cmd.x1 : currentX + cmd.x1;
                                    const y1 = cmd.type === 'Q' ? -cmd.y1 : currentY - cmd.y1;
                                    currentX = cmd.type === 'Q' ? cmd.x : currentX + cmd.x;
                                    currentY = cmd.type === 'Q' ? -cmd.y : currentY - cmd.y;
                                    const handleIn = new paper.Point(x1, y1);
                                    paperPath.add(new paper.Segment(new paper.Point(currentX, currentY), handleIn));
                                } else if (cmd.type === 'Z' || cmd.type === 'z') {
                                    // ClosePath
                                    paperPath.closePath();
                                }
                            } catch (e) {
                                console.warn(`å¤„ç†å‘½ä»¤ ${cmd.type} å¤±è´¥:`, e);
                            }
                        }
                        
                        if (paperPath.segments.length > 0) {
                            console.log('æ–¹æ³•3æˆåŠŸï¼Œåˆ›å»ºäº†', paperPath.segments.length, 'ä¸ªæ®µ');
                            return paperPath;
                        }
                    }
                } catch (e) {
                    console.warn('æ–¹æ³•3å¤±è´¥:', e);
                }
                
                console.error('æ‰€æœ‰è·¯å¾„è½¬æ¢æ–¹æ³•éƒ½å¤±è´¥äº†');
                return null;
            } catch (e) { 
                console.error("è·¯å¾„è§£æå‡ºé”™:", e, e.stack); 
                return null; 
            }
        }
        
        // ä»å¯¼å…¥çš„ SVG ä¸­æå–è·¯å¾„ï¼ˆæ”¯æŒ Path, CompoundPath, Groupï¼‰
        function extractPathFromImported(imported) {
            if (!imported) {
                console.warn('extractPathFromImported: imported ä¸º null');
                return null;
            }
            
            console.log('extractPathFromImported: ç±»å‹ =', imported.constructor.name);
            
            // å¦‚æœæ˜¯å•ä¸ªè·¯å¾„ï¼Œç›´æ¥è¿”å›
            if (imported instanceof paper.Path) {
                const segCount = imported.segments ? imported.segments.length : 0;
                console.log('æ˜¯ Pathï¼Œæ®µæ•°:', segCount);
                if (segCount > 0) {
                    return imported;
                } else {
                    console.warn('Path æ²¡æœ‰æ®µ');
                    return null;
                }
            }
            
            // å¦‚æœæ˜¯å¤åˆè·¯å¾„
            if (imported instanceof paper.CompoundPath) {
                const childCount = imported.children ? imported.children.length : 0;
                const segCount = imported.segments ? imported.segments.length : 0;
                console.log('æ˜¯ CompoundPathï¼Œå­è·¯å¾„æ•°:', childCount, 'æ®µæ•°:', segCount);
                
                // å¦‚æœæœ‰æ®µï¼Œç›´æ¥è¿”å›
                if (segCount > 0) {
                    return imported;
                }
                
                // å¦‚æœæ²¡æœ‰æ®µä½†æœ‰å­è·¯å¾„ï¼Œæ£€æŸ¥å­è·¯å¾„
                if (childCount > 0) {
                    let hasValidChild = false;
                    for (let i = 0; i < imported.children.length; i++) {
                        const child = imported.children[i];
                        if (child.segments && child.segments.length > 0) {
                            hasValidChild = true;
                            break;
                        }
                    }
                    if (hasValidChild) {
                        return imported;
                    }
                }
                
                console.warn('CompoundPath æ²¡æœ‰æœ‰æ•ˆæ®µæˆ–å­è·¯å¾„');
                return null;
            }
            
            // å¦‚æœæ˜¯ Groupï¼Œæå–æ‰€æœ‰è·¯å¾„
            if (imported instanceof paper.Group) {
                console.log('æ˜¯ Groupï¼Œå­å…ƒç´ æ•°:', imported.children ? imported.children.length : 0);
                const paths = [];
                function extractPaths(item) {
                    if (item instanceof paper.Path) {
                        if (item.segments && item.segments.length > 0) {
                            paths.push(item);
                        }
                    } else if (item instanceof paper.CompoundPath) {
                        if ((item.segments && item.segments.length > 0) || 
                            (item.children && item.children.length > 0)) {
                            paths.push(item);
                        }
                    } else if (item instanceof paper.Group && item.children) {
                        item.children.forEach(child => extractPaths(child));
                    }
                }
                extractPaths(imported);
                
                console.log('ä» Group ä¸­æå–åˆ°', paths.length, 'ä¸ªæœ‰æ•ˆè·¯å¾„');
                
                if (paths.length === 0) {
                    console.warn('Group ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆè·¯å¾„');
                    return null;
                }
                
                // å¦‚æœåªæœ‰ä¸€ä¸ªè·¯å¾„ï¼Œç›´æ¥è¿”å›
                if (paths.length === 1) {
                    console.log('åªæœ‰ä¸€ä¸ªè·¯å¾„ï¼Œç›´æ¥è¿”å›');
                    return paths[0];
                }
                
                // å¤šä¸ªè·¯å¾„ï¼Œåˆ›å»º CompoundPath
                try {
                    console.log('å°è¯•åˆ›å»º CompoundPathï¼ŒåŒ…å«', paths.length, 'ä¸ªè·¯å¾„');
                    const compound = new paper.CompoundPath();
                    for (let i = 0; i < paths.length; i++) {
                        try {
                            // å°†è·¯å¾„æ·»åŠ åˆ° CompoundPath
                            compound.addChild(paths[i]);
                        } catch (e) {
                            console.warn(`æ·»åŠ è·¯å¾„ ${i} åˆ° CompoundPath å¤±è´¥:`, e);
                        }
                    }
                    if (compound.children && compound.children.length > 0) {
                        console.log('æˆåŠŸåˆ›å»º CompoundPathï¼ŒåŒ…å«', compound.children.length, 'ä¸ªå­è·¯å¾„');
                        return compound;
                    }
                } catch (e) {
                    console.warn('åˆ›å»º CompoundPath å¤±è´¥ï¼Œå°è¯• unite:', e);
                }
                
                // å¦‚æœ CompoundPath å¤±è´¥ï¼Œå°è¯• uniteï¼ˆå¯èƒ½å¤±è´¥ï¼Œä½†å€¼å¾—ä¸€è¯•ï¼‰
                try {
                    console.log('å°è¯•ä½¿ç”¨ unite åˆå¹¶è·¯å¾„');
                    let merged = paths[0];
                    for (let i = 1; i < paths.length; i++) {
                        try {
                            merged = merged.unite(paths[i]);
                        } catch (e) {
                            console.warn(`åˆå¹¶ç¬¬${i+1}ä¸ªè·¯å¾„å¤±è´¥ï¼Œè·³è¿‡:`, e);
                        }
                    }
                    console.log('unite åˆå¹¶æˆåŠŸ');
                    return merged;
                } catch (e) {
                    console.warn('åˆå¹¶è·¯å¾„å¤±è´¥ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªè·¯å¾„:', e);
                    return paths[0];
                }
            }
            
            console.warn('æœªçŸ¥çš„å¯¼å…¥ç±»å‹:', imported.constructor.name);
            return null;
        }

        // è¾…åŠ©å‡½æ•°ï¼šç¡®ä¿è·¯å¾„å±…ä¸­åˆ°åŸç‚¹
        function centerPath(path) {
            if (!path) return;
            try {
                const bounds = path.bounds;
                const centerX = (bounds.left + bounds.right) / 2;
                const centerY = (bounds.top + bounds.bottom) / 2;
                path.translate([-centerX, -centerY]);
            } catch (e) {
                console.warn('centerPath å¤±è´¥:', e);
            }
        }

        // æ ¸å¿ƒæ¸²æŸ“å¼•æ“
        function render() {
            paper.project.clear();
            
            if (!currentFont) {
                new paper.PointText({ 
                    point: paper.view.center, 
                    content: 'è¯·åœ¨å·¦ä¾§è½½å…¥å­—ä½“æ–‡ä»¶å¼€å§‹è®¾è®¡', 
                    fillColor: '#9ca3af', 
                    fontSize: 24, 
                    justification: 'center' 
                });
                paper.view.draw();
                return;
            }

            try {
                // 1. è·å–æ–‡å­—å¹¶ç¼©æ”¾
                const otPath = currentFont.getPath(currentHanzi, 0, 0, 100);
                const bbox = otPath.getBoundingBox();
                const fontW = bbox.x2 - bbox.x1;
                const fontH = bbox.y2 - bbox.y1;
                if (fontW <= 0) return;
                
                H = W * (fontH / fontW); 
                const scaleFactor = W / fontW;
                const heightHintEl = document.getElementById('heightHint');
                if (heightHintEl) heightHintEl.textContent = 'å½“å‰æ¨¡å‹å®é™…æ€»é«˜åº¦ H: çº¦ ' + H.toFixed(1) + ' mm';
                
                let hanziPath = convertToPaperPath(otPath);
                if (!hanziPath) {
                    console.error('æ±‰å­—è·¯å¾„è½¬æ¢å¤±è´¥ - hanziPath ä¸º null');
                    new paper.PointText({ 
                        point: paper.view.center, 
                        content: 'è·¯å¾„è½¬æ¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥å­—ä½“æ–‡ä»¶\nè¯·æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯', 
                        fillColor: '#ef4444', 
                        fontSize: 18, 
                        justification: 'center' 
                    });
                    paper.view.draw();
                    return;
                }
                
                // æ£€æŸ¥è·¯å¾„æ˜¯å¦æœ‰æ•ˆï¼ˆæ”¯æŒ Path å’Œ CompoundPathï¼‰
                let isValidPath = false;
                if (hanziPath instanceof paper.Path) {
                    // æ™®é€šè·¯å¾„ï¼šæ£€æŸ¥ segments
                    isValidPath = hanziPath.segments && hanziPath.segments.length > 0;
                    if (isValidPath) {
                        console.log('è·¯å¾„è½¬æ¢æˆåŠŸï¼ˆPathï¼‰ï¼Œæ®µæ•°:', hanziPath.segments.length);
                    }
                } else if (hanziPath instanceof paper.CompoundPath) {
                    // å¤åˆè·¯å¾„ï¼šæ£€æŸ¥ children æˆ– segments
                    const hasChildren = hanziPath.children && hanziPath.children.length > 0;
                    const hasSegments = hanziPath.segments && hanziPath.segments.length > 0;
                    isValidPath = hasChildren || hasSegments;
                    if (isValidPath) {
                        console.log('è·¯å¾„è½¬æ¢æˆåŠŸï¼ˆCompoundPathï¼‰ï¼Œå­è·¯å¾„æ•°:', hasChildren ? hanziPath.children.length : 0, 'æ®µæ•°:', hasSegments ? hanziPath.segments.length : 0);
                    }
                }
                
                if (!isValidPath) {
                    console.error('æ±‰å­—è·¯å¾„è½¬æ¢å¤±è´¥ - è·¯å¾„æ— æ•ˆ');
                    console.error('è·¯å¾„å¯¹è±¡:', hanziPath);
                    console.error('è·¯å¾„ç±»å‹:', hanziPath.constructor.name);
                    
                    // å¦‚æœæ˜¯ CompoundPathï¼Œæ£€æŸ¥å­è·¯å¾„
                    if (hanziPath instanceof paper.CompoundPath && hanziPath.children) {
                        console.log('æ˜¯ CompoundPathï¼Œå­è·¯å¾„æ•°é‡:', hanziPath.children.length);
                        for (let i = 0; i < hanziPath.children.length; i++) {
                            const child = hanziPath.children[i];
                            console.log(`å­è·¯å¾„ ${i}:`, child.constructor.name, 'æ®µæ•°:', child.segments ? child.segments.length : 0);
                        }
                    }
                    
                    new paper.PointText({ 
                        point: paper.view.center, 
                        content: 'è·¯å¾„è½¬æ¢å¤±è´¥ï¼šè·¯å¾„æ— æ•ˆ\nè¯·æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯', 
                        fillColor: '#ef4444', 
                        fontSize: 16, 
                        justification: 'center' 
                    });
                    paper.view.draw();
                    return;
                }
                
                // ç¼©æ”¾è·¯å¾„
                try {
                    hanziPath.scale(scaleFactor);
                } catch (e) {
                    console.error('ç¼©æ”¾è·¯å¾„å¤±è´¥:', e);
                    return;
                }
                
                // å°†è·¯å¾„ä¸­å¿ƒç‚¹ç§»åŠ¨åˆ°åŸç‚¹ï¼ˆ0,0ï¼‰
                try {
                    const bounds = hanziPath.bounds;
                    const centerX = (bounds.left + bounds.right) / 2;
                    const centerY = (bounds.top + bounds.bottom) / 2;
                    hanziPath.translate([-centerX, -centerY]);
                } catch (e) {
                    console.error('å±…ä¸­è·¯å¾„å¤±è´¥:', e);
                    // å¦‚æœå±…ä¸­å¤±è´¥ï¼Œè‡³å°‘å°è¯•ç§»åŠ¨åˆ°åŸç‚¹é™„è¿‘
                    try {
                        hanziPath.position = new paper.Point(0, 0);
                    } catch (e2) {
                        console.error('è®¾ç½®ä½ç½®å¤±è´¥:', e2);
                    }
                }

                // è‡ªåŠ¨é˜²æ‰å­—ï¼šæ¡¥æ¥æ–­å¼€çš„ç‹¬ç«‹éƒ¨ä»¶ï¼ˆIslandï¼‰ï¼Œä¸å¤„ç†å£/ç”°ç­‰å­”æ´
                if (autoBridgeEnabled && hanziPath) {
                    try {
                        const bridgeW = Math.max(0.5, autoBridgeWidth);
                        let islands = [];

                        if (hanziPath instanceof paper.CompoundPath && hanziPath.children && hanziPath.children.length > 0) {
                            const outers = [];
                            const holes = [];
                            for (let i = 0; i < hanziPath.children.length; i++) {
                                const child = hanziPath.children[i];
                                try {
                                    const area = typeof child.area === 'function' ? child.area() : child.area;
                                    const isHole = (typeof area === 'number' && area < 0) || (child.clockwise === true);
                                    if (isHole) holes.push(child);
                                    else outers.push(child);
                                } catch (e) { outers.push(child); }
                            }
                            for (let i = 0; i < outers.length; i++) {
                                const outer = outers[i];
                                try {
                                    const comp = new paper.CompoundPath({ insert: false });
                                    comp.addChild(outer.clone());
                                    for (let h = 0; h < holes.length; h++) {
                                        try {
                                            const hole = holes[h];
                                            const c = hole.bounds ? hole.bounds.center : hole.position;
                                            if (outer.contains(c)) comp.addChild(hole.clone());
                                        } catch (e2) {}
                                    }
                                    islands.push(comp);
                                } catch (e) {
                                    try {
                                        islands.push(outer.clone());
                                    } catch (e2) { console.warn('å²›æå–å¤±è´¥:', e2); }
                                }
                            }
                            if (islands.length === 0 && outers.length > 0) {
                                outers.forEach(function(o) { try { islands.push(o.clone()); } catch (e) {} });
                            }
                        } else if (hanziPath instanceof paper.Path) {
                            try { islands.push(hanziPath.clone()); } catch (e) {}
                        }

                        while (islands.length > 1) {
                            let bestDist = Infinity;
                            let bestA = null, bestB = null, bestI = 0, bestJ = 0;

                            function samplePoints(path, n) {
                                const pts = [];
                                try {
                                    const len = path.length;
                                    if (len <= 0 && path.segments && path.segments.length > 0) {
                                        path.segments.forEach(function(s) { if (s.point) pts.push(s.point); });
                                        return pts;
                                    }
                                    const step = Math.max(len / n, 0.5);
                                    for (let o = 0; o <= len; o += step) {
                                        const p = path.getPointAt(o);
                                        if (p) pts.push(p);
                                    }
                                } catch (e) {
                                    if (path.segments) path.segments.forEach(function(s) { if (s.point) pts.push(s.point); });
                                }
                                return pts;
                            }

                            for (let i = 0; i < islands.length; i++) {
                                for (let j = i + 1; j < islands.length; j++) {
                                    const ptsI = samplePoints(islands[i], 24);
                                    const ptsJ = samplePoints(islands[j], 24);
                                    for (let pi = 0; pi < ptsI.length; pi++) {
                                        try {
                                            const p = ptsI[pi];
                                            const nearest = islands[j].getNearestPoint(p);
                                            const d = p.getDistance(nearest);
                                            if (d < bestDist && d > 1e-6) {
                                                bestDist = d;
                                                bestA = p;
                                                bestB = nearest;
                                                bestI = i;
                                                bestJ = j;
                                            }
                                        } catch (e) {}
                                    }
                                    for (let pj = 0; pj < ptsJ.length; pj++) {
                                        try {
                                            const p = ptsJ[pj];
                                            const nearest = islands[i].getNearestPoint(p);
                                            const d = p.getDistance(nearest);
                                            if (d < bestDist && d > 1e-6) {
                                                bestDist = d;
                                                bestA = nearest;
                                                bestB = p;
                                                bestI = i;
                                                bestJ = j;
                                            }
                                        } catch (e) {}
                                    }
                                }
                            }

                            if (bestA === null || bestB === null) {
                                console.warn('è‡ªåŠ¨è¿ç­‹ï¼šæ— æ³•æ‰¾åˆ°å¯è¿æ¥å²›å¯¹ï¼Œåœæ­¢');
                                break;
                            }

                            try {
                                const len = bestA.getDistance(bestB);
                                const center = bestA.add(bestB).divide(2);
                                const angle = Math.atan2(bestB.y - bestA.y, bestB.x - bestA.x);
                                const deg = (angle * 180 / Math.PI);
                                const bridgeRect = new paper.Path.Rectangle({
                                    point: [-len / 2, -bridgeW / 2],
                                    size: [len, bridgeW],
                                    insert: false
                                });
                                bridgeRect.rotate(deg, center);

                                let merged = islands[bestI].unite(bridgeRect);
                                if (merged) {
                                    try {
                                        merged = merged.unite(islands[bestJ]);
                                    } catch (e) { merged = null; }
                                }
                                if (merged) {
                                    try {
                                        islands[bestI].remove();
                                        islands[bestJ].remove();
                                    } catch (e) {}
                                    islands = islands.filter(function(_, idx) { return idx !== bestI && idx !== bestJ; });
                                    islands.push(merged);
                                    console.log('è‡ªåŠ¨è¿ç­‹ï¼šæˆåŠŸè¿æ¥ä¸€å¯¹å²›ï¼Œå‰©ä½™å²›æ•°', islands.length);
                                } else {
                                    console.warn('è‡ªåŠ¨è¿ç­‹ï¼šunite å¤±è´¥ï¼Œè·³è¿‡è¯¥å¯¹');
                                    break;
                                }
                            } catch (err) {
                                console.warn('è‡ªåŠ¨è¿ç­‹å¤±è´¥:', err);
                                break;
                            }
                        }

                        if (islands.length === 1) {
                            try {
                                hanziPath.remove();
                                hanziPath = islands[0];
                            } catch (e) {}
                        }
                    } catch (err) {
                        console.error('è‡ªåŠ¨é˜²æ‰å­—å¤„ç†å¼‚å¸¸:', err);
                    }
                }

                // 2. è®¡ç®—å¯çœ¼å­”ä½ (ä»…ä¿ç•™åº•éƒ¨çš„2ä¸ªæ¨ªæ§½ï¼Œç”¨äºæ’å…¥å¤§åº•æ¿)
                // 2. åŠ¨æ€è®¡ç®—å¯çœ¼å­”ä½ (æ ¹æ® baseSupportType å†³å®šåº•éƒ¨æ˜¯åŒå­”è¿˜æ˜¯å•å­”)
                const holeW_H = mainTenonWidth - kerf; const holeH_H = T - kerf;
                const botY = innerYSpacing / 2 + offsetY;
                const leftX = -innerXSpacing/2 + offsetX;
                const rightX = innerXSpacing/2 + offsetX;
                const centerX = offsetX;

                let holesCoords = [];
                if (baseSupportType === 'dual') {
                    holesCoords = [
                        { x: leftX, y: botY, w: holeW_H, h: holeH_H },
                        { x: rightX, y: botY, w: holeW_H, h: holeH_H }
                    ];
                } else {
                    holesCoords = [
                        { x: centerX, y: botY, w: holeW_H, h: holeH_H }
                    ];
                }

                let frontPanel = hanziPath.clone();
                let backPanel = hanziPath.clone();
                let blueMarkers = [];

                // 3. æŒ–å­” (åªåœ¨åº•éƒ¨æŒ–2ä¸ªå­”)
                holesCoords.forEach(coord => {
                    const holeRect = new paper.Path.Rectangle({
                        point: [coord.x - coord.w/2, coord.y - coord.h/2],
                        size: [coord.w, coord.h]
                    });
                    try {
                        let newFront = frontPanel.subtract(holeRect);
                        let newBack = backPanel.subtract(holeRect);
                        frontPanel.remove(); backPanel.remove();
                        frontPanel = newFront; backPanel = newBack;
                    } catch(e) {
                        holeRect.strokeColor = '#3b82f6'; holeRect.strokeWidth = 2; holeRect.fillColor = null;
                        blueMarkers.push(holeRect);
                    }
                });

                // 4. ç”Ÿæˆå†…éƒ¨éª¨æ¶ï¼šå·¦å³ä¸¤å—æ— ä¾§æ¦«çš„ä¾§æ¿ + åº•éƒ¨å¸¦æ§½çš„å¤§åº•æ¿
                function createSidePanel() {
                    const h = sidePanelHeight; // ä½¿ç”¨åŠ¨æ€é«˜åº¦å˜é‡
                    let panel = new paper.Path.Rectangle({ point: [-D/2, -h/2], size: [D, h] });
                    // ä¾§æ¿åº•éƒ¨çš„æ¦«å¤´ä½ç½®ä¹Ÿéœ€è¦æ ¹æ®æ–°é«˜åº¦ h é‡æ–°è®¡ç®— (h/2 ç¡®ä¿åœ¨åº•éƒ¨è¾¹ç¼˜)
                    const bot_tenon = new paper.Path.Rectangle({ point: [-(sideTenonWidth + kerf)/2, h/2], size: [sideTenonWidth + kerf, T + kerf] });
                    try { panel = panel.unite(bot_tenon); } catch(e) {}
                    return panel;
                }
                const leftSide = createSidePanel();
                const rightSide = createSidePanel();

                function createBottomPlate() {
                    const bpW = innerXSpacing + 20;
                    let plate = new paper.Path.Rectangle({ point: [-bpW/2, -D/2], size: [bpW, D] });

                    // 1. é¡¶éƒ¨å’Œåº•éƒ¨çš„å‡¸æ¦« (ä¸ä¸»é¢æ¿è¿æ¥) -> å‡¸æ¦«å˜å¤§ (+kerf)
                    const tabW = mainTenonWidth + kerf;
                    const tabH = T + kerf;
                    if (baseSupportType === 'dual') {
                        const fl = new paper.Path.Rectangle({ point: [-innerXSpacing/2 - tabW/2, D/2], size: [tabW, tabH] });
                        const fr = new paper.Path.Rectangle({ point: [innerXSpacing/2 - tabW/2, D/2], size: [tabW, tabH] });
                        const bl = new paper.Path.Rectangle({ point: [-innerXSpacing/2 - tabW/2, -D/2 - tabH], size: [tabW, tabH] });
                        const br = new paper.Path.Rectangle({ point: [innerXSpacing/2 - tabW/2, -D/2 - tabH], size: [tabW, tabH] });
                        try { plate = plate.unite(fl).unite(fr).unite(bl).unite(br); } catch(e) {}
                    } else {
                        const f_center = new paper.Path.Rectangle({ point: [-tabW/2, D/2], size: [tabW, tabH] });
                        const b_center = new paper.Path.Rectangle({ point: [-tabW/2, -D/2 - tabH], size: [tabW, tabH] });
                        try { plate = plate.unite(f_center).unite(b_center); } catch(e) {}
                    }

                    // 2. å·¦å³ä¸¤ä¾§çš„å¯çœ¼å­”æ´ (ä¸ä¾§æ¿è¿æ¥) -> å­”æ´å˜å° (-kerf)
                    const holeW = T - kerf;
                    const holeH = sideTenonWidth - kerf;
                    const left_hole = new paper.Path.Rectangle({ point: [-innerXSpacing/2 - holeW/2, -holeH/2], size: [holeW, holeH] });
                    const right_hole = new paper.Path.Rectangle({ point: [innerXSpacing/2 - holeW/2, -holeH/2], size: [holeW, holeH] });
                    try {
                        plate = plate.subtract(left_hole).subtract(right_hole);
                    } catch(e) {}
                    return plate;
                }
                const bottomPlate = createBottomPlate();

                // æ¸…æ´—è·¯å¾„ï¼šå»é™¤å†—ä½™é¡¶ç‚¹ã€é‡ç»„æ‹“æ‰‘ï¼Œä¾› 3D æ‹‰ä¼¸å‡å°‘ä¸‰è§’å‰–åˆ†å¤±è´¥ï¼ˆåŸç”Ÿæ”¯æŒå­”æ´ï¼‰
                function cleanPathFor3D(path) {
                    if (!path) return null;
                    var eps = 0.08;
                    try {
                        // CompoundPathï¼šä¿ç•™æ‰€æœ‰å­è·¯å¾„ï¼ˆå¤–è½®å»“ + å­”æ´ï¼‰ï¼Œé€æ¡æ¸…æ´—
                        if (path.children && path.children.length > 0) {
                            var compound = new paper.CompoundPath();
                            for (var c = 0; c < path.children.length; c++) {
                                var child = path.children[c];
                                var segs = child.segments;
                                if (!segs || segs.length < 2) continue;
                                var points = [];
                                for (var i = 0; i < segs.length; i++) {
                                    var p = segs[i].point;
                                    if (points.length === 0 || p.getDistance(points[points.length - 1]) > eps)
                                        points.push(p.clone());
                                }
                                if (child.closed && points.length > 1)
                                    points.push(points[0].clone());
                                var subPath = new paper.Path(points);
                                if (child.closed) subPath.closePath();
                                compound.addChild(subPath);
                            }
                            return compound.children.length > 0 ? compound : path.clone();
                        }
                        // å•ä¸€è·¯å¾„
                        var segs = path.segments;
                        if (!segs || segs.length < 2) return path.clone();
                        var points = [];
                        for (var i = 0; i < segs.length; i++) {
                            var p = segs[i].point;
                            if (points.length === 0 || p.getDistance(points[points.length - 1]) > eps)
                                points.push(p.clone());
                        }
                        if (path.closed && points.length > 1)
                            points.push(points[0].clone());
                        var newPath = new paper.Path(points);
                        if (path.closed) newPath.closePath();
                        return newPath;
                    } catch (e) {
                        return path.clone();
                    }
                }

                // ä¾› 3D ä½¿ç”¨ï¼ˆä½¿ç”¨æ¸…æ´—åçš„è·¯å¾„ï¼‰
                computedParts.front = cleanPathFor3D(frontPanel); if (computedParts.front) centerPath(computedParts.front);
                computedParts.back = cleanPathFor3D(backPanel); if (computedParts.back) centerPath(computedParts.back);
                computedParts.sideL = cleanPathFor3D(leftSide); if (computedParts.sideL) centerPath(computedParts.sideL);
                computedParts.sideR = cleanPathFor3D(rightSide); if (computedParts.sideR) centerPath(computedParts.sideR);
                computedParts.bottom = cleanPathFor3D(bottomPlate); if (computedParts.bottom) centerPath(computedParts.bottom);

                // 5. å°†ç”Ÿæˆçš„é›¶ä»¶æ’ç‰ˆåˆ°å±å¹•ä¸Šå¯è§çš„ä½ç½®
                const drawItem = (item, x, y, title) => {
                    item.strokeColor = '#ef4444'; // çº¢è‰²åˆ‡å‰²çº¿
                    item.strokeWidth = 1;
                    item.fillColor = null;
                    item.bounds.topLeft = new paper.Point(x * scale, y * scale);
                    paper.project.activeLayer.addChild(item);
                    
                    new paper.PointText({
                        point: [x * scale + item.bounds.width/2, y * scale - 10],
                        content: title, fillColor: '#4b5563', fontSize: 14, fontWeight: 'bold', justification: 'center'
                    });
                };
                
                const drawMarkers = (markers, refPanel, refX, refY) => {
                    markers.forEach(m => { 
                        m.bounds.center = new paper.Point(
                            refPanel.bounds.center.x + m.position.x * scale, 
                            refPanel.bounds.center.y + m.position.y * scale
                        );
                        paper.project.activeLayer.addChild(m); 
                    });
                };

                let currentY = 30;
                // ä¿å­˜ç”¨äºå¯¼å‡ºçš„é¢æ¿å…‹éš†ï¼ˆ1 å•ä½ = 1mmï¼Œæ—  scale ä¸æ’ç‰ˆåç§»ï¼‰
                window.exportPanels = {
                    front: frontPanel.clone(),
                    back: backPanel.clone(),
                    left: leftSide.clone(),
                    right: rightSide.clone(),
                    bottom: bottomPlate.clone()
                };
                drawItem(frontPanel, 20, currentY, 'æ­£é¢ç«‹é¢');
                drawMarkers(blueMarkers, frontPanel, 20, currentY);
                drawItem(backPanel, 40 + W, currentY, 'èƒŒé¢ç«‹é¢');

                currentY += Math.max(H, 100) + 40;
                drawItem(leftSide, 20, currentY, 'å·¦ä¾§æ¿');
                drawItem(rightSide, 40 + D + T*2, currentY, 'å³ä¾§æ¿');
                drawItem(bottomPlate, 60 + D*2 + T*4, currentY, 'å¤§åº•æ¿');

                paper.view.draw();
                if (typeof update3DModel === 'function') update3DModel();

            } catch (err) {
                console.error("æ¸²æŸ“é‡åˆ°é”™è¯¯:", err);
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                try {
                    new paper.PointText({ 
                        point: paper.view.center, 
                        content: 'æ¸²æŸ“é”™è¯¯: ' + err.message, 
                        fillColor: '#ef4444', 
                        fontSize: 16, 
                        justification: 'center' 
                    });
                    paper.view.draw();
                } catch (e) {
                    console.error('æ— æ³•æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯:', e);
                }
            }
        }

        // ã€æè´¨å¼•æ“ã€‘æ¤´æœ¨ PBR + å•ä¾‹æè´¨ä¸ç‰ˆæœ¬é”ï¼Œæ¶ˆé™¤å¼‚æ­¥é‡å½±
        let materialTextureLoader = null;
        function getTextureLoader() {
            if (typeof THREE === 'undefined') return null;
            if (!materialTextureLoader) materialTextureLoader = new THREE.TextureLoader();
            return materialTextureLoader;
        }
        function getMaterial(type) {
            const commonSettings = {
                side: THREE.DoubleSide, depthWrite: true, depthTest: true,
                polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
            };
            switch (type) {
                case 'wood':
                    if (!woodMaterialInstance) {
                        woodMaterialInstance = new THREE.MeshStandardMaterial({
                            color: 0xffffff, // çº¯ç™½åº•è‰²ï¼Œä¸å¹²æ‰°è´´å›¾æœ¬èº«é¢œè‰²
                            roughness: 0.85, 
                            metalness: 0.1, 
                            ...commonSettings
                        });
                        const loader = getTextureLoader();
                        if (loader) {
                            const applyWoodTexture = (tex) => {
                                tex.wrapS = THREE.RepeatWrapping;
                                tex.wrapT = THREE.RepeatWrapping;
                                tex.repeat.set(0.008, 0.008);
                                woodMaterialInstance.map = tex;
                                woodMaterialInstance.needsUpdate = true;
                                if (window.scene3D && window.scene3D.renderer) {
                                    window.scene3D.renderer.render(window.scene3D.scene, window.scene3D.camera);
                                }
                            };
                            const fallbackToColor = (err) => {
                                console.warn('æœ¨çº¹è´´å›¾åŠ è½½å¤±è´¥', err);
                                woodMaterialInstance.color.setHex(0x8B5A2B);
                                woodMaterialInstance.needsUpdate = true;
                            };
                            loader.load('./basswood.jpg', applyWoodTexture, undefined, () => {
                                loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/hardwood2_diffuse.jpg', applyWoodTexture, undefined, fallbackToColor);
                            });
                        }
                    }
                    return woodMaterialInstance;
                case 'acrylic':
                    return new THREE.MeshStandardMaterial({ 
                        color: 0xcc0000,       // é²œè‰³çš„çº¢è‰²
                        roughness: 0.05,       // æä½ç²—ç³™åº¦ï¼Œäº§ç”Ÿé”åˆ©é«˜å…‰
                        metalness: 0.1,        // è½»å¾®é‡‘å±æ„Ÿå¢åŠ å¡‘æ–™çš„åå…‰åšé‡åº¦
                        transparent: true,     // å¼€å¯é€æ˜
                        opacity: 0.85,         // è®¾ç½®ä¸ºåŠé€æ˜
                        ...commonSettings 
                    });
                case 'metal':
                    return new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.35, metalness: 0.85, ...commonSettings });
                case 'default':
                default:
                    return new THREE.MeshLambertMaterial({ color: 0xffffff, ...commonSettings });
            }
        }

        // åˆå§‹åŒ– 3D åœºæ™¯ï¼ˆThree.jsï¼‰
        function init3D() {
            if (typeof THREE === 'undefined') return;
            const container = document.getElementById('threeContainer');
            if (!container) return;
            const width = container.clientWidth || 800;
            const height = container.clientHeight || 600;
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf3f4f6);
            const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 5000);
            camera.position.set(200, 150, 250);
            camera.lookAt(0, 0, 0);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            container.innerHTML = '';
            container.appendChild(renderer.domElement);
            const main3DGroup = new THREE.Group();
            scene.add(main3DGroup);
            // ã€å†·æš–åŒæ‰“å…‰ã€‘é…åˆ Phong æè´¨ï¼Œæ— ç¯å¢ƒè´´å›¾ä¹Ÿèƒ½å±‚æ¬¡åˆ†æ˜
            const ambient = new THREE.AmbientLight(0xffffff, 0.28);
            scene.add(ambient);
            const warmLight = new THREE.DirectionalLight(0xffdd99, 0.75);
            warmLight.position.set(120, 180, 120);
            scene.add(warmLight);
            const coolLight = new THREE.DirectionalLight(0xaaccff, 0.5);
            coolLight.position.set(-100, 100, -120);
            scene.add(coolLight);
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            const view3DContainer = document.getElementById('view3DContainer');
            window.scene3D = { scene, camera, renderer, controls, main3DGroup, container, view3DContainer };
            window.addEventListener('resize', function() {
                const c = document.getElementById('threeContainer');
                if (!c || !window.scene3D) return;
                const w = c.clientWidth;
                const h = c.clientHeight;
                window.scene3D.camera.aspect = w / h;
                window.scene3D.camera.updateProjectionMatrix();
                window.scene3D.renderer.setSize(w, h);
            });
            // å•ä¸€åŠ¨ç”»å¾ªç¯ï¼Œä»…å½“ 3D è§†å›¾å¯è§æ—¶æ¸²æŸ“ï¼Œé¿å…é‡å¤è§¦å‘
            (function animate3D() {
                requestAnimationFrame(animate3D);
                if (window.scene3D && window.scene3D.view3DContainer && !window.scene3D.view3DContainer.classList.contains('hidden') && window.scene3D.controls) {
                    window.scene3D.controls.update();
                    window.scene3D.renderer.render(window.scene3D.scene, window.scene3D.camera);
                }
            })();
        }

        // Paper.js è·¯å¾„ â†’ SVG å­—ç¬¦ä¸²ï¼ˆä¾› SVGLoader è§£æï¼‰
        function paperPathToSVGString(paperPath) {
            if (!paperPath) return '';
            try {
                const el = paperPath.exportSVG();
                const svgNs = 'http://www.w3.org/2000/svg';
                const svg = document.createElementNS(svgNs, 'svg');
                svg.setAttribute('xmlns', svgNs);
                const b = paperPath.bounds;
                svg.setAttribute('viewBox', [b.left, b.top, b.width, b.height].join(' '));
                if (el) svg.appendChild(el);
                return new XMLSerializer().serializeToString(svg);
            } catch (e) {
                console.warn('paperPathToSVGString failed:', e);
                return '';
            }
        }

        // ä½¿ç”¨ SVGLoader è§£æ SVG å¹¶æ‹‰ä¼¸ä¸ºç™½æ¨¡+é»‘çº¿æ¡†ï¼ˆæ”¯æŒè´å¡å°”ä¸é•‚ç©º CompoundPathï¼‰
        function paperPathToMesh(paperPath, depth, done) {
            if (typeof THREE === 'undefined' || !paperPath) {
                if (done) done(null);
                return;
            }
            const svgString = paperPathToSVGString(paperPath);
            if (!svgString) {
                if (done) done(null);
                return;
            }
            const loader = new THREE.SVGLoader();
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            loader.load(url, function(data) {
                URL.revokeObjectURL(url);
                const group = new THREE.Group();
                const currentMat = getMaterial(selectedMaterialType);
                if (data.paths && data.paths.length) {
                    data.paths.forEach(function(shapePath) {
                        try {
                            const shapes = THREE.SVGLoader.createShapes(shapePath);
                            const shapeArray = Array.isArray(shapes) ? shapes : (shapes ? [shapes] : []);
                            shapeArray.forEach(function(shape) {
                                const geometry = new THREE.ExtrudeGeometry(shape, { depth: depth, bevelEnabled: false });
                                geometry.center();

                                geometry.scale(1, -1, 1);
                                geometry.computeVertexNormals();

                                const matToUse = (selectedMaterialType === 'acrylic' || selectedMaterialType === 'wood') ? currentMat : currentMat.clone();
                                const mesh = new THREE.Mesh(geometry, matToUse);

                                const edges = new THREE.EdgesGeometry(geometry, 15);
                                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({
                                    color: 0x333333,
                                    depthTest: true,
                                    depthWrite: true
                                }));
                                mesh.add(line);

                                group.add(mesh);
                            });
                        } catch (err) {
                            console.warn('SVGLoader createShapes/Extrude failed:', err);
                        }
                    });
                }
                if (done) done(group.children.length > 0 ? group : null);
            }, undefined, function(err) {
                URL.revokeObjectURL(url);
                console.warn('SVGLoader load failed:', err);
                if (done) done(null);
            });
        }

        // æ›´æ–°3Dæ¨¡å‹ï¼ˆThree.js ç»„è£…ï¼ŒSVGLoader å¼‚æ­¥åŠ è½½ + ç‰ˆæœ¬é”é˜²é‡å ï¼‰
        function update3DModel() {
            if (typeof THREE === 'undefined' || !window.scene3D || !window.scene3D.main3DGroup) return;
            if (!computedParts.front || !computedParts.back) return;
            if (!computedParts.sideL || !computedParts.sideR || !computedParts.bottom) return;

            renderGeneration++;
            const currentGen = renderGeneration;

            const main3DGroup = window.scene3D.main3DGroup;
            while (main3DGroup.children.length) main3DGroup.remove(main3DGroup.children[0]);

            const results = {};
            let pending = 5;

            function tryAssemble() {
                if (currentGen !== renderGeneration) return;

                pending--;
                if (pending !== 0) return;

                const { front: frontMesh, back: backMesh, sideL: sideLMesh, sideR: sideRMesh, bottom: bottomMesh } = results;
                if (!frontMesh || !backMesh || !sideLMesh || !sideRMesh || !bottomMesh) return;

                const bY = innerYSpacing / 2;
                const lX = -innerXSpacing / 2 + offsetX;
                const rX = innerXSpacing / 2 + offsetX;

                frontMesh.position.set(0, 0, D / 2 + T / 2); main3DGroup.add(frontMesh);
                backMesh.position.set(0, 0, -D / 2 - T / 2); backMesh.rotation.y = Math.PI; main3DGroup.add(backMesh);
                bottomMesh.rotation.x = Math.PI / 2; bottomMesh.position.set(offsetX, -bY, 0); main3DGroup.add(bottomMesh);
                sideLMesh.rotation.y = Math.PI / 2; sideLMesh.position.set(lX, -bY + sidePanelHeight / 2 + T / 2, 0); main3DGroup.add(sideLMesh);
                sideRMesh.rotation.y = Math.PI / 2; sideRMesh.position.set(rX, -bY + sidePanelHeight / 2 + T / 2, 0); main3DGroup.add(sideRMesh);

                main3DGroup.position.y = offsetY;
                if (window.scene3D.controls) window.scene3D.controls.update();
                if (window.scene3D.renderer) window.scene3D.renderer.render(window.scene3D.scene, window.scene3D.camera);
            }

            paperPathToMesh(computedParts.front, T, function(m) { results.front = m; tryAssemble(); });
            paperPathToMesh(computedParts.back, T, function(m) { results.back = m; tryAssemble(); });
            paperPathToMesh(computedParts.sideL, T, function(m) { results.sideL = m; tryAssemble(); });
            paperPathToMesh(computedParts.sideR, T, function(m) { results.sideR = m; tryAssemble(); });
            paperPathToMesh(computedParts.bottom, T, function(m) { results.bottom = m; tryAssemble(); });
        }

        // åˆå§‹åŒ–å·²é€šè¿‡ checkAllLoaded() å‡½æ•°è‡ªåŠ¨è§¦å‘
        // å¦‚æœåŠ¨æ€åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ£€æŸ¥
        setTimeout(() => {
            if (typeof paper === 'undefined' || typeof opentype === 'undefined') {
                waitForLibraries(() => {
                    initializeApp();
                    setTimeout(() => {
                        if (typeof paper !== 'undefined') {
                            render();
                        }
                    }, 150);
                });
            }
        }, 2000);
    </script>
</body>
</html>