<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ±‰å­—æ¦«å¯ç”Ÿæˆå™¨ V5.1 (ç»ˆæä¿®å¤ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/SVGLoader.js"></script>
    <!-- Three.js 3D è£…é…é¢„è§ˆ -->
    <style>
        html, body { margin: 0; padding: 0; height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background-color: #f3f4f6; }
        body { display: flex; overflow: hidden; }
        .slider { width: 100%; height: 6px; border-radius: 3px; background: #d1d5db; outline: none; -webkit-appearance: none; appearance: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #4f46e5; cursor: pointer; border: none; box-shadow: 0 1px 3px rgba(0,0,0,0.3);}
        #paperCanvas { border: 1px solid #e5e7eb; background: #ffffff; border-radius: 0.5rem; width: 100%; height: 100%; display: block; }
        .section-title { font-weight: 600; color: #374151; margin-top: 12px; margin-bottom: 8px; font-size: 14px; border-left: 4px solid #4f46e5; padding-left: 8px;}
        details summary { cursor: pointer; list-style: none; }
        details summary::-webkit-details-marker { display: none; }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex bg-gray-100 text-gray-800 font-sans m-0 p-0">
    
    <aside class="w-80 flex-shrink-0 bg-white border-r border-gray-200 shadow-xl z-20 flex flex-col h-full">
        
        <div class="px-5 py-4 border-b border-gray-200 bg-gray-50">
            <h1 class="text-xl font-bold text-gray-800">æ±‰å­—æ¦«å¯ç”Ÿæˆå™¨ V5.2</h1>
            <p class="text-xs text-gray-500 mt-1">Uå‹æ‰¿æ‰˜åº•åº§ | ç¬”ç”»å»¶ç”Ÿ</p>
        </div>

        <div class="flex-1 overflow-y-auto pb-6">
            
            <details class="group border-b border-gray-100" open>
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-gray-50 transition-colors">
                    <span class="font-bold text-sm text-gray-700">1. åŸºç¡€è®¾ç½®</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-4 pt-1">
                    <label class="block text-xs font-medium text-gray-600 mb-1">è½½å…¥å­—ä½“ (.ttf, .otf)</label>
                    <input type="file" id="fontFile" accept=".ttf,.otf" class="block w-full text-xs text-gray-500 file:mr-3 file:py-1.5 file:px-3 file:rounded-md file:border-0 file:text-xs file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 mb-3">
                    
                    <label class="block text-xs font-medium text-gray-600 mb-1">è¾“å…¥æ±‰å­—ï¼ˆå•ä¸ªï¼‰</label>
                    <input type="text" id="hanziInput" value="ç¦" maxlength="1" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 text-xl text-center font-bold">
                </div>
            </details>

            <details class="group border-b border-gray-100" open>
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-gray-50 transition-colors">
                    <span class="font-bold text-sm text-gray-700">2. å¤–è§‚å°ºå¯¸å‚æ•°</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-4 pt-1 space-y-3">
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>åŸºå‡†å®½åº¦ W:</span> <span class="text-indigo-600"><input type="number" id="widthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="50" max="300" value="120" step="1"> mm</span></label>
                        <input type="range" id="widthSlider" min="50" max="300" value="120" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>æ€»æ·±åº¦ D (å«ä¾§æ¿):</span> <span class="text-indigo-600"><input type="number" id="depthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="20" max="200" value="60" step="1"> mm</span></label>
                        <input type="range" id="depthSlider" min="20" max="200" value="60" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>ææ–™åšåº¦ T:</span> <span class="text-indigo-600"><input type="number" id="thicknessValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="1" max="10" value="3" step="0.1"> mm</span></label>
                        <input type="range" id="thicknessSlider" min="1" max="10" value="3" step="0.1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>ä¾§æ¿é«˜åº¦ H2:</span> <span class="text-indigo-600"><input type="number" id="sidePanelHeightValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="20" max="200" value="50" step="1"> mm</span></label>
                        <input type="range" id="sidePanelHeightSlider" min="20" max="200" value="50" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>ä¸»é¢æ¿æ’å£å®½åº¦:</span> <span class="text-indigo-600"><input type="number" id="mainTenonWidthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="5" max="50" value="10" step="1"> mm</span></label>
                        <input type="range" id="mainTenonWidthSlider" min="5" max="50" value="10" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>ä¾§æ¿æ’å£å®½åº¦:</span> <span class="text-indigo-600"><input type="number" id="sideTenonWidthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="5" max="50" value="10" step="1"> mm</span></label>
                        <input type="range" id="sideTenonWidthSlider" min="5" max="50" value="10" step="1" class="slider">
                    </div>
                    <hr class="border-dashed border-gray-200 my-2">
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>å‰²ç¼è¡¥å¿ (ä¸¥ä¸åˆç¼):</span> <span class="text-indigo-600"><input type="number" id="kerfValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="-0.5" max="0.5" value="0.10" step="0.01"> mm</span></label>
                        <input type="range" id="kerfSlider" min="-0.5" max="0.5" value="0.10" step="0.01" class="slider">
                    </div>
                </div>
            </details>

            <details class="group border-b border-gray-100" open>
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-gray-50 transition-colors">
                    <span class="font-bold text-sm text-gray-700">3. å†…éƒ¨éª¨æ¶è°ƒèŠ‚</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-4 pt-1 space-y-3">
                    <div class="p-2 bg-gray-50 rounded-md border border-gray-200 mb-2">
                        <label class="block text-xs font-bold text-gray-700 mb-1">æ”¯æ’‘ç»“æ„ç±»å‹ï¼š</label>
                        <div class="flex gap-3 mt-1">
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="radio" name="baseType" value="dual" checked class="text-indigo-600">
                                <span class="ml-1 text-xs text-gray-600">åŒæ§½ (å¦‚:ç¦)</span>
                            </label>
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="radio" name="baseType" value="single" class="text-indigo-600">
                                <span class="ml-1 text-xs text-gray-600">å•æ§½ (å¦‚:å¹¸)</span>
                            </label>
                        </div>
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>éª¨æ¶æ°´å¹³é—´è· (å·¦å³):</span> <span class="text-indigo-600"><input type="number" id="innerXSpacingValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="20" max="200" value="60" step="1"> mm</span></label>
                        <input type="range" id="innerXSpacingSlider" min="20" max="200" value="60" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>åº•åº§æŠ¬å‡é«˜åº¦ (è·åº•éƒ¨):</span> <span class="text-indigo-600"><input type="number" id="innerYSpacingValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="20" max="200" value="60" step="1"> mm</span></label>
                        <input type="range" id="innerYSpacingSlider" min="20" max="200" value="60" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>æ•´ä½“ X è½´å¹³ç§»:</span> <span class="text-indigo-600"><input type="number" id="offsetXValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="-100" max="100" value="0" step="1"> mm</span></label>
                        <input type="range" id="offsetXSlider" min="-100" max="100" value="0" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>æ•´ä½“ Y è½´å¹³ç§»:</span> <span class="text-indigo-600"><input type="number" id="offsetYValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 text-xs font-bold bg-white text-indigo-700" min="-100" max="100" value="0" step="1"> mm</span></label>
                        <input type="range" id="offsetYSlider" min="-100" max="100" value="0" step="1" class="slider">
                    </div>
                </div>
            </details>

            <details class="group border-b border-gray-100">
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-green-50 transition-colors">
                    <span class="font-bold text-sm text-green-700">4. ä¸»æ­æ¡¥è®¾ç½® (ç»„1)</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-3 pt-1">
                    <div class="flex gap-4 flex-wrap">
                        <label class="inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="bridgeH1EnabledCheckbox" checked class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                            <span class="ml-2 text-sm font-medium text-gray-700">ä¸»æ¨ªå‘</span>
                        </label>
                        <label class="inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="bridgeV1EnabledCheckbox" checked class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                            <span class="ml-2 text-sm font-medium text-gray-700">ä¸»çºµå‘</span>
                        </label>
                    </div>
                </div>
                <div class="px-5 pb-4 pt-1 space-y-3">
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>æ¨ªå‘è¿ç­‹Yä½ç½®:</span> <span class="text-green-600"><input type="number" id="bridgeYValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-xs font-bold bg-white text-green-700" min="0" max="200" value="60" step="1"> mm</span></label>
                        <input type="range" id="bridgeYSlider" min="0" max="200" value="60" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>æ¨ªå‘è¿ç­‹ç²—ç»†(é«˜):</span> <span class="text-green-600"><input type="number" id="bridgeHeightValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-xs font-bold bg-white text-green-700" min="1" max="10" value="3" step="0.5"> mm</span></label>
                        <input type="range" id="bridgeHeightSlider" min="1" max="10" value="3" step="0.5" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>æ¨ªå‘è¿ç­‹é•¿åº¦:</span> <span class="text-green-600"><input type="number" id="bridgeH_LengthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-xs font-bold bg-white text-green-700" min="10" max="300" value="120" step="1"> mm</span></label>
                        <input type="range" id="bridgeH_LengthSlider" min="10" max="300" value="120" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>æ¨ªå‘è¿ç­‹å·¦å³åç§»:</span> <span class="text-green-600"><input type="number" id="bridgeH_OffsetXValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-xs font-bold bg-white text-green-700" min="-150" max="150" value="0" step="1"> mm</span></label>
                        <input type="range" id="bridgeH_OffsetXSlider" min="-150" max="150" value="0" step="1" class="slider">
                    </div>
                    <hr class="border-dashed border-gray-200 my-2">
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>çºµå‘è¿ç­‹Xä½ç½®:</span> <span class="text-green-600"><input type="number" id="bridgeXValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-xs font-bold bg-white text-green-700" min="0" max="200" value="60" step="1"> mm</span></label>
                        <input type="range" id="bridgeXSlider" min="0" max="200" value="60" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>çºµå‘è¿ç­‹ç²—ç»†(å®½):</span> <span class="text-green-600"><input type="number" id="bridgeWidthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-xs font-bold bg-white text-green-700" min="1" max="10" value="3" step="0.5"> mm</span></label>
                        <input type="range" id="bridgeWidthSlider" min="1" max="10" value="3" step="0.5" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>çºµå‘è¿ç­‹é•¿åº¦:</span> <span class="text-green-600"><input type="number" id="bridgeV_LengthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-xs font-bold bg-white text-green-700" min="10" max="300" value="120" step="1"> mm</span></label>
                        <input type="range" id="bridgeV_LengthSlider" min="10" max="300" value="120" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>çºµå‘è¿ç­‹ä¸Šä¸‹åç§»:</span> <span class="text-green-600"><input type="number" id="bridgeV_OffsetYValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-xs font-bold bg-white text-green-700" min="-150" max="150" value="0" step="1"> mm</span></label>
                        <input type="range" id="bridgeV_OffsetYSlider" min="-150" max="150" value="0" step="1" class="slider">
                    </div>
                </div>
            </details>

            <details class="group border-b border-gray-100">
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-blue-50 transition-colors">
                    <span class="font-bold text-sm text-blue-700">5. è¾…æ­æ¡¥è®¾ç½® (ç»„2-ä¿®è¡¥å­¤å²›)</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-3 pt-1">
                    <div class="flex gap-4 flex-wrap">
                        <label class="inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="bridgeH2EnabledCheckbox" checked class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                            <span class="ml-2 text-sm font-medium text-gray-700">è¾…æ¨ªå‘</span>
                        </label>
                        <label class="inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="bridgeV2EnabledCheckbox" checked class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                            <span class="ml-2 text-sm font-medium text-gray-700">è¾…çºµå‘</span>
                        </label>
                    </div>
                </div>
                <div class="px-5 pb-4 pt-1 space-y-3">
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>è¾…æ¨ªè¿ç­‹Yä½ç½®:</span> <span class="text-blue-600"><input type="number" id="bridge2YValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-500 text-xs font-bold bg-white text-blue-700" min="0" max="200" value="30" step="1"> mm</span></label>
                        <input type="range" id="bridge2YSlider" min="0" max="200" value="30" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>è¾…æ¨ªè¿ç­‹ç²—ç»†:</span> <span class="text-blue-600"><input type="number" id="bridge2HeightValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-500 text-xs font-bold bg-white text-blue-700" min="1" max="10" value="3" step="0.5"> mm</span></label>
                        <input type="range" id="bridge2HeightSlider" min="1" max="10" value="3" step="0.5" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>è¾…æ¨ªè¿ç­‹é•¿åº¦:</span> <span class="text-blue-600"><input type="number" id="bridge2H_LengthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-500 text-xs font-bold bg-white text-blue-700" min="10" max="300" value="30" step="1"> mm</span></label>
                        <input type="range" id="bridge2H_LengthSlider" min="10" max="300" value="30" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>è¾…æ¨ªè¿ç­‹å·¦å³åç§»:</span> <span class="text-blue-600"><input type="number" id="bridge2H_OffsetXValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-500 text-xs font-bold bg-white text-blue-700" min="-150" max="150" value="-30" step="1"> mm</span></label>
                        <input type="range" id="bridge2H_OffsetXSlider" min="-150" max="150" value="-30" step="1" class="slider">
                    </div>
                    <hr class="border-dashed border-gray-200 my-2">
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>è¾…çºµè¿ç­‹Xä½ç½®:</span> <span class="text-blue-600"><input type="number" id="bridge2XValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-500 text-xs font-bold bg-white text-blue-700" min="0" max="200" value="30" step="1"> mm</span></label>
                        <input type="range" id="bridge2XSlider" min="0" max="200" value="30" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>è¾…çºµè¿ç­‹ç²—ç»†:</span> <span class="text-blue-600"><input type="number" id="bridge2WidthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-500 text-xs font-bold bg-white text-blue-700" min="1" max="10" value="3" step="0.5"> mm</span></label>
                        <input type="range" id="bridge2WidthSlider" min="1" max="10" value="3" step="0.5" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>è¾…çºµè¿ç­‹é•¿åº¦:</span> <span class="text-blue-600"><input type="number" id="bridge2V_LengthValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-500 text-xs font-bold bg-white text-blue-700" min="10" max="300" value="30" step="1"> mm</span></label>
                        <input type="range" id="bridge2V_LengthSlider" min="10" max="300" value="30" step="1" class="slider">
                    </div>
                    <div>
                        <label class="flex justify-between text-xs font-medium text-gray-600 mb-1"><span>è¾…çºµè¿ç­‹ä¸Šä¸‹åç§»:</span> <span class="text-blue-600"><input type="number" id="bridge2V_OffsetYValue" class="w-16 px-1 py-0.5 text-right border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-500 text-xs font-bold bg-white text-blue-700" min="-150" max="150" value="-30" step="1"> mm</span></label>
                        <input type="range" id="bridge2V_OffsetYSlider" min="-150" max="150" value="-30" step="1" class="slider">
                    </div>
                </div>
            </details>

            <details class="group border-b border-gray-100">
                <summary class="px-5 py-3 cursor-pointer list-none flex justify-between items-center bg-white hover:bg-purple-50 transition-colors">
                    <span class="font-bold text-sm text-purple-700">6. 3D æè´¨ä¸æ¸²æŸ“</span>
                    <span class="text-gray-400 transition-transform group-open:rotate-180">â–¼</span>
                </summary>
                <div class="px-5 pb-4 pt-1 space-y-3">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">é€‰æ‹©ææ–™è´¨æ„Ÿ:</label>
                        <select id="materialSelect" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500 text-sm">
                            <option value="default" selected>âšª é»˜è®¤ç™½æ¨¡ (ç”¨äºæ£€æŸ¥ç»“æ„)</option>
                            <option value="wood">ğŸªµ åŸæœ¨æ¿æ (æ¸©æš–è‡ªç„¶)</option>
                            <option value="acrylic">ğŸŸ¥ çº¢è‰²äºšå…‹åŠ› (åŠé€æ˜)</option>
                            <option value="metal">ğŸ”© æ‹‰ä¸é‡‘å± (é“åˆé‡‘)</option>
                        </select>
                    </div>
                    <p class="text-xs text-gray-400 mt-2 leading-tight">æ³¨ï¼šæè´¨ä»…ä¾›é¢„è§ˆå‚è€ƒï¼Œå®é™…æ•ˆæœå–å†³äºç‰©ç†åŠ å·¥ã€‚</p>
                </div>
            </details>

        </div>

        <div class="p-4 border-t border-gray-200 bg-white shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)] z-10">
            <button id="exportBtn" class="w-full bg-indigo-600 text-white py-3 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 font-bold shadow-md transition-all">
                â†“ ä¸‹è½½ SVG åˆ‡å‰²å›¾çº¸
            </button>
        </div>
    </aside>

    <main class="flex-1 flex flex-col h-full min-w-0 relative">
        <div class="flex border-b border-gray-200 bg-white px-4 pt-4 flex-shrink-0">
            <button id="tab2D" class="tab-btn active mr-2 px-6 py-2.5 font-bold text-sm rounded-t-lg bg-indigo-50 text-indigo-700 border-t border-l border-r border-indigo-100">2D å›¾çº¸è§†å›¾</button>
            <button id="tab3D" class="tab-btn inactive px-6 py-2.5 font-medium text-sm rounded-t-lg bg-gray-100 text-gray-500 hover:bg-gray-200">3D è£…é…é¢„è§ˆ</button>
        </div>

        <div class="flex-1 relative w-full h-full bg-gray-100">
            <div id="view2DContainer" class="absolute inset-0 w-full h-full flex flex-col">
                <div class="p-2 bg-white border-b flex justify-between items-center px-6 flex-shrink-0 shadow-sm z-10">
                    <div class="text-xs font-medium text-gray-600">
                        <span class="inline-block w-3 h-3 bg-red-500 rounded-full mr-1 align-middle"></span> çº¢è‰²ä¸ºæ¿€å…‰åˆ‡å‰²çº¿
                        <span class="inline-block w-3 h-3 bg-blue-500 rounded-full ml-4 mr-1 align-middle"></span> <span class="text-blue-600">è“è‰²ä¸ºæœªåˆ‡é€æç¤º(éœ€è°ƒèŠ‚æ»‘å—å¯¹å‡†)</span>
                    </div>
                </div>
                <div class="flex-1 w-full h-full relative overflow-hidden bg-white">
                    <canvas id="paperCanvas" resize="true" class="absolute inset-0 w-full h-full outline-none"></canvas>
                </div>
            </div>

            <div id="view3DContainer" class="absolute inset-0 w-full h-full flex flex-col hidden">
                <div class="p-2 bg-white border-b flex justify-between items-center px-6 flex-shrink-0 shadow-sm z-10">
                    <div class="text-xs font-medium text-gray-600">
                        ğŸ–±ï¸ é¼ æ ‡å·¦é”®æ—‹è½¬è§†å›¾ | ğŸ–±ï¸ é¼ æ ‡å³é”®å¹³ç§» | ğŸ–±ï¸ æ»šè½®ç¼©æ”¾
                    </div>
                </div>
                <div id="threeContainer" class="flex-1 w-full h-full outline-none bg-gray-100"></div>
            </div>
        </div>
    </main>

    <script>
        // åŠ¨æ€åŠ è½½è„šæœ¬ï¼ˆæ”¯æŒå¤šä¸ªå¤‡ç”¨ CDNï¼‰
        function loadScript(urls, onSuccess, onError, retryCount = 0) {
            if (retryCount >= urls.length) {
                onError();
                return;
            }

            const script = document.createElement('script');
            script.src = urls[retryCount];
            script.onload = () => {
                console.log('æˆåŠŸåŠ è½½:', urls[retryCount]);
                onSuccess();
            };
            script.onerror = () => {
                console.warn('åŠ è½½å¤±è´¥:', urls[retryCount], 'å°è¯•ä¸‹ä¸€ä¸ª...');
                loadScript(urls, onSuccess, onError, retryCount + 1);
            };
            document.head.appendChild(script);
        }

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        function showError(message) {
            const canvas = document.getElementById('paperCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ef4444';
                ctx.font = '18px Arial';
                ctx.fillText(message, 20, 50);
                ctx.fillText('è¯·å°è¯•ï¼š1) åˆ·æ–°é¡µé¢ 2) æ£€æŸ¥æµè§ˆå™¨éšç§è®¾ç½®', 20, 80);
                ctx.fillText('3) ä½¿ç”¨å…¶ä»–æµè§ˆå™¨ 4) æ£€æŸ¥ç½‘ç»œè¿æ¥', 20, 110);
            }
        }

        // åŠ è½½ opentype.jsï¼ˆå¤šä¸ªå¤‡ç”¨ CDNï¼‰
        const opentypeUrls = [
            'https://unpkg.com/opentype.js@1.3.4/dist/opentype.min.js',
            'https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js'
        ];

        // åŠ è½½ paper.jsï¼ˆå¤šä¸ªå¤‡ç”¨ CDNï¼‰
        const paperUrls = [
            'https://unpkg.com/paper@0.12.17/dist/paper-full.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/paper/0.12.17/paper-full.min.js',
            'https://cdn.jsdelivr.net/npm/paper@0.12.17/dist/paper-full.min.js'
        ];

        let opentypeLoaded = false;
        let paperLoaded = false;

        // åŠ è½½ opentype.js
        loadScript(
            opentypeUrls,
            () => {
                opentypeLoaded = true;
                checkAllLoaded();
            },
            () => {
                console.error('æ‰€æœ‰ opentype.js CDN éƒ½åŠ è½½å¤±è´¥');
                showError('opentype.js åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æµè§ˆå™¨è®¾ç½®');
            }
        );

        // åŠ è½½ paper.js
        loadScript(
            paperUrls,
            () => {
                paperLoaded = true;
                checkAllLoaded();
            },
            () => {
                console.error('æ‰€æœ‰ paper.js CDN éƒ½åŠ è½½å¤±è´¥');
                showError('paper.js åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æµè§ˆå™¨è®¾ç½®');
            }
        );

        // æ£€æŸ¥æ‰€æœ‰åº“æ˜¯å¦åŠ è½½å®Œæˆ
        function checkAllLoaded() {
            if (opentypeLoaded && paperLoaded && typeof opentype !== 'undefined' && typeof paper !== 'undefined') {
                console.log('æ‰€æœ‰åº“åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–');
                initializeApp();
                setTimeout(() => {
                    if (typeof paper !== 'undefined') {
                        render();
                    }
                }, 150);
            }
        }

        // ç­‰å¾…æ‰€æœ‰è„šæœ¬åŠ è½½å®Œæˆï¼ˆå¤‡ç”¨æ£€æŸ¥ï¼‰
        function waitForLibraries(callback) {
            const checkInterval = setInterval(() => {
                if (typeof paper !== 'undefined' && typeof opentype !== 'undefined') {
                    clearInterval(checkInterval);
                    callback();
                }
            }, 50);
            
            // 15ç§’è¶…æ—¶
            setTimeout(() => {
                clearInterval(checkInterval);
                if (typeof paper === 'undefined' || typeof opentype === 'undefined') {
                    console.error('åº“åŠ è½½è¶…æ—¶');
                    showError('è„šæœ¬åŠ è½½è¶…æ—¶ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®');
                }
            }, 15000);
        }

        let currentFont = null;
        let currentHanzi = 'ç¦';
        let W = 120; let H = 120; let D = 60; let T = 3;
        let sidePanelHeight = 50; // é»˜è®¤ä¾§æ¿é«˜åº¦
        let mainTenonWidth = 10;
        let sideTenonWidth = 10;
        let kerf = 0.10;
        let innerXSpacing = 60; let innerYSpacing = 60;
        let offsetX = 0; let offsetY = 0;
        let scale = 2; // SVG æ˜¾ç¤ºç¼©æ”¾æ¯”ä¾‹ (1mm = 2px)
        
        // è¿ç­‹å‚æ•°
        let bridgeY = 60;      // æ¨ªå‘è¿ç­‹Yä½ç½®
        let bridgeHeight = 3;  // æ¨ªå‘è¿ç­‹é«˜åº¦
        let bridgeX = 60;      // çºµå‘è¿ç­‹Xä½ç½®
        let bridgeWidth = 3;   // çºµå‘è¿ç­‹å®½åº¦
        let bridgeH_Length = 120;   // æ¨ªå‘è¿ç­‹é•¿åº¦
        let bridgeH_OffsetX = 0;   // æ¨ªå‘è¿ç­‹å·¦å³ç§»åŠ¨
        let bridgeV_Length = 120;   // çºµå‘è¿ç­‹é•¿åº¦
        let bridgeV_OffsetY = 0;   // çºµå‘è¿ç­‹ä¸Šä¸‹ç§»åŠ¨
        
        // ç¬¬äºŒç»„è¿ç­‹å‚æ•° (æ¬¡çº§è¾…æ§½)
        let bridge2Y = 30;     let bridge2Height = 3;  let bridge2H_Length = 30;  let bridge2H_OffsetX = -30;
        let bridge2X = 30;     let bridge2Width = 3;   let bridge2V_Length = 30;  let bridge2V_OffsetY = -30;
        
        let bridgeH1Enabled = true;  // ä¸»æ¨ªå‘è¿ç­‹
        let bridgeV1Enabled = true;  // ä¸»çºµå‘è¿ç­‹
        let bridgeH2Enabled = true;  // è¾…æ¨ªå‘è¿ç­‹
        let bridgeV2Enabled = true;  // è¾…çºµå‘è¿ç­‹
        
        let baseSupportType = 'dual'; // 'dual' è¡¨ç¤ºåŒè„šï¼Œ'single' è¡¨ç¤ºå•è„š
        
        let scene3DInited = false; // 3D åœºæ™¯æ˜¯å¦å·²åˆå§‹åŒ–
        let renderGeneration = 0; // ç”¨äºé˜²æ­¢å¼‚æ­¥æ¨¡å‹é‡å 
        let woodMaterialInstance = null; // æœ¨ææè´¨å•ä¾‹
        let selectedMaterialType = 'default'; // é»˜è®¤æè´¨
        
        // è®¡ç®—åçš„é›¶ä»¶æ•°æ®ï¼ˆç”¨äº3Dæ¸²æŸ“ï¼‰
        let computedParts = {
            front: null,
            back: null,
            sideL: null,
            sideR: null,
            bottom: null
        };
        
        function resetComputedParts() {
            computedParts = {
                front: null,
                back: null,
                sideL: null,
                sideR: null,
                bottom: null
            };
        }

        const UI = {
            fontFile: document.getElementById('fontFile'),
            hanziInput: document.getElementById('hanziInput'),
            canvas: document.getElementById('paperCanvas'),
            exportBtn: document.getElementById('exportBtn')
        };

        // åˆå§‹åŒ–å‡½æ•°ï¼ˆåœ¨åº“åŠ è½½å®Œæˆåæ‰§è¡Œï¼‰
        function initializeApp() {
            try {
                // åˆå§‹åŒ– Paper.js è§†å£ç¯å¢ƒ
                if (typeof paper === 'undefined') {
                    throw new Error('Paper.js æœªåŠ è½½');
                }
                paper.setup(UI.canvas);

                // ç»‘å®šæ‰€æœ‰æ»‘å—äº‹ä»¶çš„å¿«æ·å‡½æ•°ï¼ˆä½¿ç”¨å›è°ƒå‡½æ•°æ›´æ–°å˜é‡ï¼‰
                const bindSlider = (id, setter) => {
                    const slider = document.getElementById(id + 'Slider');
                    const valInput = document.getElementById(id + 'Value');
                    if (!slider || !valInput) {
                        console.warn(`æ‰¾ä¸åˆ°æ»‘å—å…ƒç´ : ${id}Slider æˆ– ${id}Value`);
                        return;
                    }
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const step = parseFloat(slider.step);

                    function clampToBounds(val) {
                        const n = parseFloat(val);
                        if (isNaN(n)) return parseFloat(slider.value);
                        return Math.min(max, Math.max(min, n));
                    }
                    function roundToStep(val) {
                        if (step <= 0) return val;
                        return Math.round(val / step) * step;
                    }
                    function applyAndRender(val) {
                        val = clampToBounds(val);
                        val = Math.min(max, Math.max(min, roundToStep(val)));
                        slider.value = val;
                        valInput.value = val;
                        setter(val);
                        render();
                    }

                    slider.addEventListener('input', () => {
                        valInput.value = slider.value;
                        setter(parseFloat(slider.value));
                        render();
                    });
                    valInput.addEventListener('input', () => {
                        const parsed = parseFloat(valInput.value);
                        if (isNaN(parsed)) return;
                        const safe = Math.min(max, Math.max(min, parsed));
                        slider.value = safe;
                        setter(safe);
                        render();
                    });
                    valInput.addEventListener('blur', () => {
                        applyAndRender(valInput.value);
                    });
                    valInput.addEventListener('change', () => {
                        applyAndRender(valInput.value);
                    });

                    valInput.value = slider.value;
                };
                
                bindSlider('width', (val) => { W = val; });
                bindSlider('depth', (val) => { D = val; });
                bindSlider('thickness', (val) => { T = val; });
                bindSlider('sidePanelHeight', (val) => { sidePanelHeight = val; });
                bindSlider('mainTenonWidth', (val) => { mainTenonWidth = val; });
                bindSlider('sideTenonWidth', (val) => { sideTenonWidth = val; });
                bindSlider('kerf', (val) => { kerf = val; });
                bindSlider('innerXSpacing', (val) => { innerXSpacing = val; });
                bindSlider('innerYSpacing', (val) => { innerYSpacing = val; });
                bindSlider('offsetX', (val) => { offsetX = val; });
                bindSlider('offsetY', (val) => { offsetY = val; });
                
                // ç»‘å®šè¿ç­‹æ»‘å—
                bindSlider('bridgeY', (val) => { bridgeY = val; });
                bindSlider('bridgeHeight', (val) => { bridgeHeight = val; });
                bindSlider('bridgeH_Length', (val) => { bridgeH_Length = val; });
                bindSlider('bridgeH_OffsetX', (val) => { bridgeH_OffsetX = val; });
                bindSlider('bridgeX', (val) => { bridgeX = val; });
                bindSlider('bridgeWidth', (val) => { bridgeWidth = val; });
                bindSlider('bridgeV_Length', (val) => { bridgeV_Length = val; });
                bindSlider('bridgeV_OffsetY', (val) => { bridgeV_OffsetY = val; });
                bindSlider('bridge2Y', (val) => { bridge2Y = val; });
                bindSlider('bridge2Height', (val) => { bridge2Height = val; });
                bindSlider('bridge2H_Length', (val) => { bridge2H_Length = val; });
                bindSlider('bridge2H_OffsetX', (val) => { bridge2H_OffsetX = val; });
                bindSlider('bridge2X', (val) => { bridge2X = val; });
                bindSlider('bridge2Width', (val) => { bridge2Width = val; });
                bindSlider('bridge2V_Length', (val) => { bridge2V_Length = val; });
                bindSlider('bridge2V_OffsetY', (val) => { bridge2V_OffsetY = val; });

                const bridgeH1El = document.getElementById('bridgeH1EnabledCheckbox');
                const bridgeV1El = document.getElementById('bridgeV1EnabledCheckbox');
                const bridgeH2El = document.getElementById('bridgeH2EnabledCheckbox');
                const bridgeV2El = document.getElementById('bridgeV2EnabledCheckbox');
                if (bridgeH1El) bridgeH1El.addEventListener('change', function() { bridgeH1Enabled = this.checked; render(); });
                if (bridgeV1El) bridgeV1El.addEventListener('change', function() { bridgeV1Enabled = this.checked; render(); });
                if (bridgeH2El) bridgeH2El.addEventListener('change', function() { bridgeH2Enabled = this.checked; render(); });
                if (bridgeV2El) bridgeV2El.addEventListener('change', function() { bridgeV2Enabled = this.checked; render(); });

                const radioButtons = document.querySelectorAll('input[name="baseType"]');
                radioButtons.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        baseSupportType = e.target.value;
                        render();
                    });
                });

                // Tab åˆ‡æ¢ï¼š2D å›¾çº¸ / 3D è£…é…é¢„è§ˆ
                const view2DContainer = document.getElementById('view2DContainer');
                const view3DContainer = document.getElementById('view3DContainer');
                const tab2D = document.getElementById('tab2D');
                const tab3D = document.getElementById('tab3D');
                if (tab2D && tab3D && view2DContainer && view3DContainer) {
                    tab2D.addEventListener('click', function() {
                        view2DContainer.classList.remove('hidden');
                        view3DContainer.classList.add('hidden');
                        tab2D.classList.add('active', 'font-bold', 'bg-indigo-50', 'text-indigo-700', 'border-indigo-100');
                        tab2D.classList.remove('font-medium', 'bg-gray-100', 'text-gray-500');
                        tab3D.classList.remove('active', 'font-bold', 'bg-indigo-50', 'text-indigo-700', 'border-indigo-100');
                        tab3D.classList.add('font-medium', 'bg-gray-100', 'text-gray-500');
                    });
                    tab3D.addEventListener('click', function() {
                        view3DContainer.classList.remove('hidden');
                        view2DContainer.classList.add('hidden');
                        tab3D.classList.add('active', 'font-bold', 'bg-indigo-50', 'text-indigo-700', 'border-indigo-100');
                        tab3D.classList.remove('font-medium', 'bg-gray-100', 'text-gray-500');
                        tab2D.classList.remove('active', 'font-bold', 'bg-indigo-50', 'text-indigo-700', 'border-indigo-100');
                        tab2D.classList.add('font-medium', 'bg-gray-100', 'text-gray-500');
                        if (typeof scene3DInited === 'undefined' || !scene3DInited) {
                            if (typeof init3D === 'function') init3D();
                            scene3DInited = true;
                        }
                        if (typeof update3DModel === 'function') update3DModel();
                    });
                }

                UI.fontFile.addEventListener('change', async (e) => {
                    if (!e.target.files[0]) return;
                    try {
                        const arrayBuffer = await e.target.files[0].arrayBuffer();
                        currentFont = opentype.parse(arrayBuffer);
                        currentHanzi = UI.hanziInput.value || 'ç¦';
                        render();
                    } catch (err) { 
                        alert('å­—ä½“åŠ è½½å¤±è´¥: ' + err.message); 
                    }
                });

                UI.hanziInput.addEventListener('input', (e) => { 
                    currentHanzi = e.target.value || 'ç¦'; 
                    render(); 
                });

                UI.exportBtn.addEventListener('click', () => {
                    if (!currentFont) return alert('è¯·å…ˆä¸Šä¼ å­—ä½“');
                    const panels = window.exportPanels;
                    if (!panels || !panels.front) return alert('è¯·å…ˆç”Ÿæˆå›¾çº¸ï¼ˆæ¸²æŸ“ä¸€æ¬¡åå†å¯¼å‡ºï¼‰');

                    const gap = 10;
                    const f = panels.front, b = panels.back, l = panels.left, r = panels.right, bot = panels.bottom;
                    const fB = f.bounds, bB = b.bounds, lB = l.bounds, rB = r.bounds, botB = bot.bounds;

                    function pathToSvgPaths(item) {
                        try {
                            const el = item.exportSVG({ asString: false });
                            if (!el) return '';
                            const pathEls = el.tagName && el.tagName.toLowerCase() === 'path' ? [el] : (el.querySelectorAll ? Array.from(el.querySelectorAll('path')) : []);
                            return pathEls.map(p => {
                                const d = p.getAttribute('d');
                                return d ? `<path d="${d.replace(/"/g, '&quot;')}" stroke-width="0.001" fill="none" stroke="#000"/>` : '';
                            }).filter(Boolean).join('');
                        } catch (e) { return ''; }
                    }

                    const row0H = Math.max(fB.height, bB.height);
                    const row1Y = row0H + gap;
                    const row1H = Math.max(lB.height, rB.height);
                    const row2Y = row1Y + row1H + gap;

                    const totalW = Math.max(fB.width + gap + bB.width, lB.width + gap + rB.width, botB.width);
                    const totalH = row2Y + botB.height;

                    const svgPaths = [
                        `<g transform="translate(${-fB.left}, ${-fB.top})">${pathToSvgPaths(f)}</g>`,
                        `<g transform="translate(${fB.width + gap - bB.left}, ${-bB.top})">${pathToSvgPaths(b)}</g>`,
                        `<g transform="translate(${-lB.left}, ${row1Y - lB.top})">${pathToSvgPaths(l)}</g>`,
                        `<g transform="translate(${lB.width + gap - rB.left}, ${row1Y - rB.top})">${pathToSvgPaths(r)}</g>`,
                        `<g transform="translate(${-botB.left}, ${row2Y - botB.top})">${pathToSvgPaths(bot)}</g>`
                    ].join('\n');

                    const svgString = '<?xml version="1.0" encoding="utf-8"?>\n' +
                        '<svg xmlns="http://www.w3.org/2000/svg" ' +
                        `width="${totalW}mm" height="${totalH}mm" ` +
                        `viewBox="0 0 ${totalW} ${totalH}">\n` +
                        svgPaths + '\n</svg>';

                    const blob = new Blob([svgString], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `HanziStructure_${currentHanzi}_W${W}_D${D}_T${T}.svg`;
                    a.click();
                    URL.revokeObjectURL(url);
                });

                // ç»‘å®šæè´¨é€‰æ‹©äº‹ä»¶
                const materialSelect = document.getElementById('materialSelect');
                if (materialSelect) {
                    materialSelect.addEventListener('change', (e) => {
                        selectedMaterialType = e.target.value;
                        render();
                    });
                }
            } catch (err) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', err);
                const canvas = document.getElementById('paperCanvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ef4444';
                    ctx.font = '18px Arial';
                    ctx.fillText('åˆå§‹åŒ–å¤±è´¥: ' + err.message, 20, 50);
                }
            }
        }

        // ã€åšå¦‚ç£çŸ³çš„å­—ä½“è§£æå¼•æ“ã€‘
        function convertToPaperPath(otPath) {
            console.log('å¼€å§‹è½¬æ¢è·¯å¾„...');
            try {
                // æ–¹æ³•1: ç›´æ¥ä½¿ç”¨ toPathData() åˆ›å»º SVG è·¯å¾„ï¼ˆæœ€å¯é ï¼‰
                try {
                    const pathData = otPath.toPathData(2);
                    console.log('toPathData() æˆåŠŸï¼Œè·¯å¾„æ•°æ®é•¿åº¦:', pathData ? pathData.length : 0);
                    
                    if (pathData && pathData.trim()) {
                        // åˆ›å»º SVG å…ƒç´ 
                        const svgNS = 'http://www.w3.org/2000/svg';
                        const svg = document.createElementNS(svgNS, 'svg');
                        svg.setAttribute('xmlns', svgNS);
                        const path = document.createElementNS(svgNS, 'path');
                        path.setAttribute('d', pathData);
                        svg.appendChild(path);
                        
                        console.log('å°è¯•å¯¼å…¥ SVG...');
                        // ä½¿ç”¨ SVG å¯¼å…¥ï¼Œå®ƒä¼šè‡ªåŠ¨å¤„ç†å¤šä¸ªæ–­å¼€çš„ç¬”ç”»ï¼ˆå¤šä¸ª M å‘½ä»¤ï¼‰å¹¶åˆ›å»º CompoundPath
                        let imported = paper.project.importSVG(svg, { insert: false });
                        console.log('å¯¼å…¥ç»“æœç±»å‹:', imported ? imported.constructor.name : 'null');
                        
                        if (imported) {
                            let paperPath = extractPathFromImported(imported);
                            if (paperPath) {
                                console.log('æˆåŠŸæå–è·¯å¾„ï¼Œç±»å‹:', paperPath.constructor.name, 'æ®µæ•°:', paperPath.segments ? paperPath.segments.length : 0);
                                // --- ä¿®æ­£ï¼šç§»é™¤ Y è½´ç¿»è½¬ï¼Œè§£å†³æ±‰å­—å€’ç«‹é—®é¢˜ ---
                                // try {
                                //     paperPath.scale(1, -1);
                                //     console.log('Yè½´ç¿»è½¬æˆåŠŸ');
                                // } catch (e) {
                                //     console.warn('ç¿»è½¬ Y è½´å¤±è´¥:', e);
                                // }
                                // -----------------------------------------
                                return paperPath;
                            } else {
                                console.warn('æå–è·¯å¾„å¤±è´¥');
                            }
                        } else {
                            console.warn('SVG å¯¼å…¥è¿”å› null');
                        }
                    } else {
                        console.warn('è·¯å¾„æ•°æ®ä¸ºç©º');
                    }
                } catch (e) {
                    console.warn('æ–¹æ³•1å¤±è´¥:', e);
                }
                
                // æ–¹æ³•2: ä½¿ç”¨ toSVG() ç„¶åè§£æ
                try {
                    const svgString = otPath.toSVG(2);
                    console.log('toSVG() æˆåŠŸï¼Œå­—ç¬¦ä¸²é•¿åº¦:', svgString ? svgString.length : 0);
                    
                    if (svgString) {
                        // å°è¯•æå–è·¯å¾„æ•°æ®
                        const pathMatch = svgString.match(/d=["']([^"']*)["']/);
                        if (pathMatch && pathMatch[1]) {
                            const pathData = pathMatch[1].trim();
                            console.log('æå–åˆ°è·¯å¾„æ•°æ®ï¼Œé•¿åº¦:', pathData.length);
                            
                            if (pathData) {
                                const svgNS = 'http://www.w3.org/2000/svg';
                                const svg = document.createElementNS(svgNS, 'svg');
                                svg.setAttribute('xmlns', svgNS);
                                const path = document.createElementNS(svgNS, 'path');
                                path.setAttribute('d', pathData);
                                svg.appendChild(path);
                                
                                let imported = paper.project.importSVG(svg, { insert: false });
                                if (imported) {
                                    let paperPath = extractPathFromImported(imported);
                                    if (paperPath) {
                                        // --- ä¿®æ­£ï¼šç§»é™¤ Y è½´ç¿»è½¬ ---
                                        // try {
                                        //     paperPath.scale(1, -1);
                                        // } catch (e) {
                                        //     console.warn('ç¿»è½¬ Y è½´å¤±è´¥:', e);
                                        // }
                                        // ---------------------------
                                        return paperPath;
                                    }
                                }
                            }
                        } else {
                            // å¦‚æœåŒ…å«å®Œæ•´çš„ SVGï¼Œå°è¯•ç›´æ¥è§£æ
                            if (svgString.includes('<svg') || svgString.includes('<path')) {
                                try {
                                    const parser = new DOMParser();
                                    const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
                                    const svgElement = svgDoc.documentElement;
                                    
                                    // æ£€æŸ¥è§£æé”™è¯¯
                                    const parserError = svgDoc.querySelector('parsererror');
                                    if (parserError) {
                                        console.warn('SVG è§£æé”™è¯¯:', parserError.textContent);
                                    } else {
                                        let imported = paper.project.importSVG(svgElement, { insert: false });
                                        if (imported) {
                                            let paperPath = extractPathFromImported(imported);
                                            if (paperPath) {
                                                // --- ä¿®æ­£ï¼šç§»é™¤ Y è½´ç¿»è½¬ ---
                                                // try {
                                                //     paperPath.scale(1, -1);
                                                // } catch (e) {
                                                //     console.warn('ç¿»è½¬ Y è½´å¤±è´¥:', e);
                                                // }
                                                // ---------------------------
                                                return paperPath;
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.warn('DOMParser å¤±è´¥:', e);
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.warn('æ–¹æ³•2å¤±è´¥:', e);
                }
                
                // æ–¹æ³•3: ç›´æ¥ä» opentype.js çš„ commands åˆ›å»º Paper.js è·¯å¾„
                // (æ–¹æ³•3æœ¬èº«çš„é€»è¾‘ä¸éœ€è¦ç¿»è½¬ï¼Œä¿æŒåŸæ ·)
                try {
                    console.log('å°è¯•æ–¹æ³•3: ç›´æ¥ä» commands åˆ›å»ºè·¯å¾„');
                    const commands = otPath.commands;
                    if (commands && commands.length > 0) {
                        console.log('æ‰¾åˆ°', commands.length, 'ä¸ªå‘½ä»¤');
                        
                        // åˆ›å»ºæ–°çš„ Paper.js è·¯å¾„
                        const paperPath = new paper.Path();
                        let currentX = 0, currentY = 0;
                        
                        for (let i = 0; i < commands.length; i++) {
                            const cmd = commands[i];
                            try {
                                if (cmd.type === 'M' || cmd.type === 'm') {
                                    // MoveTo
                                    currentX = cmd.type === 'M' ? cmd.x : currentX + cmd.x;
                                    currentY = cmd.type === 'M' ? -cmd.y : currentY - cmd.y;
                                    if (paperPath.segments.length === 0) {
                                        paperPath.moveTo(currentX, currentY);
                                    } else {
                                        paperPath.add(new paper.Point(currentX, currentY));
                                    }
                                } else if (cmd.type === 'L' || cmd.type === 'l') {
                                    // LineTo
                                    currentX = cmd.type === 'L' ? cmd.x : currentX + cmd.x;
                                    currentY = cmd.type === 'L' ? -cmd.y : currentY - cmd.y;
                                    paperPath.add(new paper.Point(currentX, currentY));
                                } else if (cmd.type === 'C' || cmd.type === 'c') {
                                    // Cubic Bezier
                                    const x1 = cmd.type === 'C' ? cmd.x1 : currentX + cmd.x1;
                                    const y1 = cmd.type === 'C' ? -cmd.y1 : currentY - cmd.y1;
                                    const x2 = cmd.type === 'C' ? cmd.x2 : currentX + cmd.x2;
                                    const y2 = cmd.type === 'C' ? -cmd.y2 : currentY - cmd.y2;
                                    currentX = cmd.type === 'C' ? cmd.x : currentX + cmd.x;
                                    currentY = cmd.type === 'C' ? -cmd.y : currentY - cmd.y;
                                    const handleIn = new paper.Point(x1, y1);
                                    const handleOut = new paper.Point(x2, y2);
                                    paperPath.add(new paper.Segment(new paper.Point(currentX, currentY), handleIn, handleOut));
                                } else if (cmd.type === 'Q' || cmd.type === 'q') {
                                    // Quadratic Bezier (è½¬æ¢ä¸ºä¸‰æ¬¡è´å¡å°”)
                                    const x1 = cmd.type === 'Q' ? cmd.x1 : currentX + cmd.x1;
                                    const y1 = cmd.type === 'Q' ? -cmd.y1 : currentY - cmd.y1;
                                    currentX = cmd.type === 'Q' ? cmd.x : currentX + cmd.x;
                                    currentY = cmd.type === 'Q' ? -cmd.y : currentY - cmd.y;
                                    const handleIn = new paper.Point(x1, y1);
                                    paperPath.add(new paper.Segment(new paper.Point(currentX, currentY), handleIn));
                                } else if (cmd.type === 'Z' || cmd.type === 'z') {
                                    // ClosePath
                                    paperPath.closePath();
                                }
                            } catch (e) {
                                console.warn(`å¤„ç†å‘½ä»¤ ${cmd.type} å¤±è´¥:`, e);
                            }
                        }
                        
                        if (paperPath.segments.length > 0) {
                            console.log('æ–¹æ³•3æˆåŠŸï¼Œåˆ›å»ºäº†', paperPath.segments.length, 'ä¸ªæ®µ');
                            return paperPath;
                        }
                    }
                } catch (e) {
                    console.warn('æ–¹æ³•3å¤±è´¥:', e);
                }
                
                console.error('æ‰€æœ‰è·¯å¾„è½¬æ¢æ–¹æ³•éƒ½å¤±è´¥äº†');
                return null;
            } catch (e) { 
                console.error("è·¯å¾„è§£æå‡ºé”™:", e, e.stack); 
                return null; 
            }
        }
        
        // ä»å¯¼å…¥çš„ SVG ä¸­æå–è·¯å¾„ï¼ˆæ”¯æŒ Path, CompoundPath, Groupï¼‰
        function extractPathFromImported(imported) {
            if (!imported) {
                console.warn('extractPathFromImported: imported ä¸º null');
                return null;
            }
            
            console.log('extractPathFromImported: ç±»å‹ =', imported.constructor.name);
            
            // å¦‚æœæ˜¯å•ä¸ªè·¯å¾„ï¼Œç›´æ¥è¿”å›
            if (imported instanceof paper.Path) {
                const segCount = imported.segments ? imported.segments.length : 0;
                console.log('æ˜¯ Pathï¼Œæ®µæ•°:', segCount);
                if (segCount > 0) {
                    return imported;
                } else {
                    console.warn('Path æ²¡æœ‰æ®µ');
                    return null;
                }
            }
            
            // å¦‚æœæ˜¯å¤åˆè·¯å¾„
            if (imported instanceof paper.CompoundPath) {
                const childCount = imported.children ? imported.children.length : 0;
                const segCount = imported.segments ? imported.segments.length : 0;
                console.log('æ˜¯ CompoundPathï¼Œå­è·¯å¾„æ•°:', childCount, 'æ®µæ•°:', segCount);
                
                // å¦‚æœæœ‰æ®µï¼Œç›´æ¥è¿”å›
                if (segCount > 0) {
                    return imported;
                }
                
                // å¦‚æœæ²¡æœ‰æ®µä½†æœ‰å­è·¯å¾„ï¼Œæ£€æŸ¥å­è·¯å¾„
                if (childCount > 0) {
                    let hasValidChild = false;
                    for (let i = 0; i < imported.children.length; i++) {
                        const child = imported.children[i];
                        if (child.segments && child.segments.length > 0) {
                            hasValidChild = true;
                            break;
                        }
                    }
                    if (hasValidChild) {
                        return imported;
                    }
                }
                
                console.warn('CompoundPath æ²¡æœ‰æœ‰æ•ˆæ®µæˆ–å­è·¯å¾„');
                return null;
            }
            
            // å¦‚æœæ˜¯ Groupï¼Œæå–æ‰€æœ‰è·¯å¾„
            if (imported instanceof paper.Group) {
                console.log('æ˜¯ Groupï¼Œå­å…ƒç´ æ•°:', imported.children ? imported.children.length : 0);
                const paths = [];
                function extractPaths(item) {
                    if (item instanceof paper.Path) {
                        if (item.segments && item.segments.length > 0) {
                            paths.push(item);
                        }
                    } else if (item instanceof paper.CompoundPath) {
                        if ((item.segments && item.segments.length > 0) || 
                            (item.children && item.children.length > 0)) {
                            paths.push(item);
                        }
                    } else if (item instanceof paper.Group && item.children) {
                        item.children.forEach(child => extractPaths(child));
                    }
                }
                extractPaths(imported);
                
                console.log('ä» Group ä¸­æå–åˆ°', paths.length, 'ä¸ªæœ‰æ•ˆè·¯å¾„');
                
                if (paths.length === 0) {
                    console.warn('Group ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆè·¯å¾„');
                    return null;
                }
                
                // å¦‚æœåªæœ‰ä¸€ä¸ªè·¯å¾„ï¼Œç›´æ¥è¿”å›
                if (paths.length === 1) {
                    console.log('åªæœ‰ä¸€ä¸ªè·¯å¾„ï¼Œç›´æ¥è¿”å›');
                    return paths[0];
                }
                
                // å¤šä¸ªè·¯å¾„ï¼Œåˆ›å»º CompoundPath
                try {
                    console.log('å°è¯•åˆ›å»º CompoundPathï¼ŒåŒ…å«', paths.length, 'ä¸ªè·¯å¾„');
                    const compound = new paper.CompoundPath();
                    for (let i = 0; i < paths.length; i++) {
                        try {
                            // å°†è·¯å¾„æ·»åŠ åˆ° CompoundPath
                            compound.addChild(paths[i]);
                        } catch (e) {
                            console.warn(`æ·»åŠ è·¯å¾„ ${i} åˆ° CompoundPath å¤±è´¥:`, e);
                        }
                    }
                    if (compound.children && compound.children.length > 0) {
                        console.log('æˆåŠŸåˆ›å»º CompoundPathï¼ŒåŒ…å«', compound.children.length, 'ä¸ªå­è·¯å¾„');
                        return compound;
                    }
                } catch (e) {
                    console.warn('åˆ›å»º CompoundPath å¤±è´¥ï¼Œå°è¯• unite:', e);
                }
                
                // å¦‚æœ CompoundPath å¤±è´¥ï¼Œå°è¯• uniteï¼ˆå¯èƒ½å¤±è´¥ï¼Œä½†å€¼å¾—ä¸€è¯•ï¼‰
                try {
                    console.log('å°è¯•ä½¿ç”¨ unite åˆå¹¶è·¯å¾„');
                    let merged = paths[0];
                    for (let i = 1; i < paths.length; i++) {
                        try {
                            merged = merged.unite(paths[i]);
                        } catch (e) {
                            console.warn(`åˆå¹¶ç¬¬${i+1}ä¸ªè·¯å¾„å¤±è´¥ï¼Œè·³è¿‡:`, e);
                        }
                    }
                    console.log('unite åˆå¹¶æˆåŠŸ');
                    return merged;
                } catch (e) {
                    console.warn('åˆå¹¶è·¯å¾„å¤±è´¥ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªè·¯å¾„:', e);
                    return paths[0];
                }
            }
            
            console.warn('æœªçŸ¥çš„å¯¼å…¥ç±»å‹:', imported.constructor.name);
            return null;
        }

        // è¾…åŠ©å‡½æ•°ï¼šç¡®ä¿è·¯å¾„å±…ä¸­åˆ°åŸç‚¹
        function centerPath(path) {
            if (!path) return;
            try {
                const bounds = path.bounds;
                const centerX = (bounds.left + bounds.right) / 2;
                const centerY = (bounds.top + bounds.bottom) / 2;
                path.translate([-centerX, -centerY]);
            } catch (e) {
                console.warn('centerPath å¤±è´¥:', e);
            }
        }

        // æ ¸å¿ƒæ¸²æŸ“å¼•æ“
        function render() {
            paper.project.clear();
            
            if (!currentFont) {
                new paper.PointText({ 
                    point: paper.view.center, 
                    content: 'è¯·åœ¨å·¦ä¾§è½½å…¥å­—ä½“æ–‡ä»¶å¼€å§‹è®¾è®¡', 
                    fillColor: '#9ca3af', 
                    fontSize: 24, 
                    justification: 'center' 
                });
                paper.view.draw();
                return;
            }

            try {
                // 1. è·å–æ–‡å­—å¹¶ç¼©æ”¾
                const otPath = currentFont.getPath(currentHanzi, 0, 0, 100);
                const bbox = otPath.getBoundingBox();
                const fontW = bbox.x2 - bbox.x1;
                const fontH = bbox.y2 - bbox.y1;
                if (fontW <= 0) return;
                
                H = W * (fontH / fontW); 
                const scaleFactor = W / fontW;
                
                // æ›´æ–°è¿ç­‹æ»‘å—èŒƒå›´ï¼ˆåŠ¨æ€è·Ÿéšæ±‰å­—å°ºå¯¸ï¼‰
                const bridgeYSlider = document.getElementById('bridgeYSlider');
                const bridgeXSlider = document.getElementById('bridgeXSlider');
                const bridge2YSlider = document.getElementById('bridge2YSlider');
                const bridge2XSlider = document.getElementById('bridge2XSlider');
                if (bridgeYSlider && H > 0) {
                    bridgeYSlider.max = Math.max(H, 200);
                    if (parseFloat(bridgeYSlider.value) > H) {
                        bridgeYSlider.value = H / 2;
                        bridgeY = H / 2;
                        document.getElementById('bridgeYValue').textContent = Math.round(bridgeY);
                    }
                }
                if (bridgeXSlider && W > 0) {
                    bridgeXSlider.max = Math.max(W, 200);
                    if (parseFloat(bridgeXSlider.value) > W) {
                        bridgeXSlider.value = W / 2;
                        bridgeX = W / 2;
                        document.getElementById('bridgeXValue').textContent = Math.round(bridgeX);
                    }
                }
                if (bridge2YSlider && H > 0) {
                    bridge2YSlider.max = Math.max(H, 200);
                    if (parseFloat(bridge2YSlider.value) > H) {
                        bridge2YSlider.value = H / 2;
                        bridge2Y = H / 2;
                        document.getElementById('bridge2YValue').textContent = Math.round(bridge2Y);
                    }
                }
                if (bridge2XSlider && W > 0) {
                    bridge2XSlider.max = Math.max(W, 200);
                    if (parseFloat(bridge2XSlider.value) > W) {
                        bridge2XSlider.value = W / 2;
                        bridge2X = W / 2;
                        document.getElementById('bridge2XValue').textContent = Math.round(bridge2X);
                    }
                }
                
                let hanziPath = convertToPaperPath(otPath);
                if (!hanziPath) {
                    console.error('æ±‰å­—è·¯å¾„è½¬æ¢å¤±è´¥ - hanziPath ä¸º null');
                    new paper.PointText({ 
                        point: paper.view.center, 
                        content: 'è·¯å¾„è½¬æ¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥å­—ä½“æ–‡ä»¶\nè¯·æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯', 
                        fillColor: '#ef4444', 
                        fontSize: 18, 
                        justification: 'center' 
                    });
                    paper.view.draw();
                    return;
                }
                
                // æ£€æŸ¥è·¯å¾„æ˜¯å¦æœ‰æ•ˆï¼ˆæ”¯æŒ Path å’Œ CompoundPathï¼‰
                let isValidPath = false;
                if (hanziPath instanceof paper.Path) {
                    // æ™®é€šè·¯å¾„ï¼šæ£€æŸ¥ segments
                    isValidPath = hanziPath.segments && hanziPath.segments.length > 0;
                    if (isValidPath) {
                        console.log('è·¯å¾„è½¬æ¢æˆåŠŸï¼ˆPathï¼‰ï¼Œæ®µæ•°:', hanziPath.segments.length);
                    }
                } else if (hanziPath instanceof paper.CompoundPath) {
                    // å¤åˆè·¯å¾„ï¼šæ£€æŸ¥ children æˆ– segments
                    const hasChildren = hanziPath.children && hanziPath.children.length > 0;
                    const hasSegments = hanziPath.segments && hanziPath.segments.length > 0;
                    isValidPath = hasChildren || hasSegments;
                    if (isValidPath) {
                        console.log('è·¯å¾„è½¬æ¢æˆåŠŸï¼ˆCompoundPathï¼‰ï¼Œå­è·¯å¾„æ•°:', hasChildren ? hanziPath.children.length : 0, 'æ®µæ•°:', hasSegments ? hanziPath.segments.length : 0);
                    }
                }
                
                if (!isValidPath) {
                    console.error('æ±‰å­—è·¯å¾„è½¬æ¢å¤±è´¥ - è·¯å¾„æ— æ•ˆ');
                    console.error('è·¯å¾„å¯¹è±¡:', hanziPath);
                    console.error('è·¯å¾„ç±»å‹:', hanziPath.constructor.name);
                    
                    // å¦‚æœæ˜¯ CompoundPathï¼Œæ£€æŸ¥å­è·¯å¾„
                    if (hanziPath instanceof paper.CompoundPath && hanziPath.children) {
                        console.log('æ˜¯ CompoundPathï¼Œå­è·¯å¾„æ•°é‡:', hanziPath.children.length);
                        for (let i = 0; i < hanziPath.children.length; i++) {
                            const child = hanziPath.children[i];
                            console.log(`å­è·¯å¾„ ${i}:`, child.constructor.name, 'æ®µæ•°:', child.segments ? child.segments.length : 0);
                        }
                    }
                    
                    new paper.PointText({ 
                        point: paper.view.center, 
                        content: 'è·¯å¾„è½¬æ¢å¤±è´¥ï¼šè·¯å¾„æ— æ•ˆ\nè¯·æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯', 
                        fillColor: '#ef4444', 
                        fontSize: 16, 
                        justification: 'center' 
                    });
                    paper.view.draw();
                    return;
                }
                
                // ç¼©æ”¾è·¯å¾„
                try {
                    hanziPath.scale(scaleFactor);
                } catch (e) {
                    console.error('ç¼©æ”¾è·¯å¾„å¤±è´¥:', e);
                    return;
                }
                
                // å°†è·¯å¾„ä¸­å¿ƒç‚¹ç§»åŠ¨åˆ°åŸç‚¹ï¼ˆ0,0ï¼‰
                try {
                    const bounds = hanziPath.bounds;
                    const centerX = (bounds.left + bounds.right) / 2;
                    const centerY = (bounds.top + bounds.bottom) / 2;
                    hanziPath.translate([-centerX, -centerY]);
                } catch (e) {
                    console.error('å±…ä¸­è·¯å¾„å¤±è´¥:', e);
                    // å¦‚æœå±…ä¸­å¤±è´¥ï¼Œè‡³å°‘å°è¯•ç§»åŠ¨åˆ°åŸç‚¹é™„è¿‘
                    try {
                        hanziPath.position = new paper.Point(0, 0);
                    } catch (e2) {
                        console.error('è®¾ç½®ä½ç½®å¤±è´¥:', e2);
                    }
                }

                // 2. è®¡ç®—å¯çœ¼å­”ä½ (ä»…ä¿ç•™åº•éƒ¨çš„2ä¸ªæ¨ªæ§½ï¼Œç”¨äºæ’å…¥å¤§åº•æ¿)
                // 2. åŠ¨æ€è®¡ç®—å¯çœ¼å­”ä½ (æ ¹æ® baseSupportType å†³å®šåº•éƒ¨æ˜¯åŒå­”è¿˜æ˜¯å•å­”)
                const holeW_H = mainTenonWidth - kerf; const holeH_H = T - kerf;
                const botY = innerYSpacing / 2 + offsetY;
                const leftX = -innerXSpacing/2 + offsetX;
                const rightX = innerXSpacing/2 + offsetX;
                const centerX = offsetX;

                let holesCoords = [];
                if (baseSupportType === 'dual') {
                    holesCoords = [
                        { x: leftX, y: botY, w: holeW_H, h: holeH_H },
                        { x: rightX, y: botY, w: holeW_H, h: holeH_H }
                    ];
                } else {
                    holesCoords = [
                        { x: centerX, y: botY, w: holeW_H, h: holeH_H }
                    ];
                }

                let frontPanel = hanziPath.clone();
                let backPanel = hanziPath.clone();
                let blueMarkers = [];

                // 3. æŒ–å­” (åªåœ¨åº•éƒ¨æŒ–2ä¸ªå­”)
                holesCoords.forEach(coord => {
                    const holeRect = new paper.Path.Rectangle({
                        point: [coord.x - coord.w/2, coord.y - coord.h/2],
                        size: [coord.w, coord.h]
                    });
                    try {
                        let newFront = frontPanel.subtract(holeRect);
                        let newBack = backPanel.subtract(holeRect);
                        frontPanel.remove(); backPanel.remove();
                        frontPanel = newFront; backPanel = newBack;
                    } catch(e) {
                        holeRect.strokeColor = '#3b82f6'; holeRect.strokeWidth = 2; holeRect.fillColor = null;
                        blueMarkers.push(holeRect);
                    }
                });

                // 3.5. ç¬”ç”»å»¶ç”Ÿè¿æ¥ï¼ˆä¸¤ç»„ä¼ªç¬”ç”»ï¼ŒæŒ‰å¼€å…³å†³å®šæ˜¯å¦å¯ç”¨ï¼‰
                const addBridges = (front, back) => {
                    const performUnion = (panel, bridge) => {
                        try {
                            const result = panel.unite(bridge.clone({ insert: false }));
                            panel.remove();
                            return result; // ç»ä¸ä½¿ç”¨ simplify()
                        } catch (e) { return panel; }
                    };

                    if (bridgeH1Enabled) {
                        const h1Y = bridgeY - H / 2;
                        const hBridge1 = new paper.Path.Rectangle({
                            point: [bridgeH_OffsetX - bridgeH_Length / 2, h1Y - bridgeHeight / 2],
                            size: [bridgeH_Length, bridgeHeight], insert: false
                        });
                        front = performUnion(front, hBridge1);
                        back = performUnion(back, hBridge1);
                    }
                    if (bridgeV1Enabled) {
                        const v1X = bridgeX - W / 2;
                        const vBridge1 = new paper.Path.Rectangle({
                            point: [v1X - bridgeWidth / 2, bridgeV_OffsetY - bridgeV_Length / 2],
                            size: [bridgeWidth, bridgeV_Length], insert: false
                        });
                        front = performUnion(front, vBridge1);
                        back = performUnion(back, vBridge1);
                    }
                    if (bridgeH2Enabled) {
                        const h2Y = bridge2Y - H / 2;
                        const hBridge2 = new paper.Path.Rectangle({
                            point: [bridge2H_OffsetX - bridge2H_Length / 2, h2Y - bridge2Height / 2],
                            size: [bridge2H_Length, bridge2Height], insert: false
                        });
                        front = performUnion(front, hBridge2);
                        back = performUnion(back, hBridge2);
                    }
                    if (bridgeV2Enabled) {
                        const v2X = bridge2X - W / 2;
                        const vBridge2 = new paper.Path.Rectangle({
                            point: [v2X - bridge2Width / 2, bridge2V_OffsetY - bridge2V_Length / 2],
                            size: [bridge2Width, bridge2V_Length], insert: false
                        });
                        front = performUnion(front, vBridge2);
                        back = performUnion(back, vBridge2);
                    }

                    return { front, back };
                };

                try {
                    const bridged = addBridges(frontPanel, backPanel);
                    frontPanel = bridged.front;
                    backPanel = bridged.back;
                } catch (e) {
                    console.error('ç¬”ç”»å»¶ç”Ÿè¿æ¥å¤±è´¥:', e);
                }

                // 4. ç”Ÿæˆå†…éƒ¨éª¨æ¶ï¼šå·¦å³ä¸¤å—æ— ä¾§æ¦«çš„ä¾§æ¿ + åº•éƒ¨å¸¦æ§½çš„å¤§åº•æ¿
                function createSidePanel() {
                    const h = sidePanelHeight; // ä½¿ç”¨åŠ¨æ€é«˜åº¦å˜é‡
                    let panel = new paper.Path.Rectangle({ point: [-D/2, -h/2], size: [D, h] });
                    // ä¾§æ¿åº•éƒ¨çš„æ¦«å¤´ä½ç½®ä¹Ÿéœ€è¦æ ¹æ®æ–°é«˜åº¦ h é‡æ–°è®¡ç®— (h/2 ç¡®ä¿åœ¨åº•éƒ¨è¾¹ç¼˜)
                    const bot_tenon = new paper.Path.Rectangle({ point: [-(sideTenonWidth + kerf)/2, h/2], size: [sideTenonWidth + kerf, T + kerf] });
                    try { panel = panel.unite(bot_tenon); } catch(e) {}
                    return panel;
                }
                const leftSide = createSidePanel();
                const rightSide = createSidePanel();

                function createBottomPlate() {
                    const bpW = innerXSpacing + 20;
                    let plate = new paper.Path.Rectangle({ point: [-bpW/2, -D/2], size: [bpW, D] });

                    // 1. é¡¶éƒ¨å’Œåº•éƒ¨çš„å‡¸æ¦« (ä¸ä¸»é¢æ¿è¿æ¥) -> å‡¸æ¦«å˜å¤§ (+kerf)
                    const tabW = mainTenonWidth + kerf;
                    const tabH = T + kerf;
                    if (baseSupportType === 'dual') {
                        const fl = new paper.Path.Rectangle({ point: [-innerXSpacing/2 - tabW/2, D/2], size: [tabW, tabH] });
                        const fr = new paper.Path.Rectangle({ point: [innerXSpacing/2 - tabW/2, D/2], size: [tabW, tabH] });
                        const bl = new paper.Path.Rectangle({ point: [-innerXSpacing/2 - tabW/2, -D/2 - tabH], size: [tabW, tabH] });
                        const br = new paper.Path.Rectangle({ point: [innerXSpacing/2 - tabW/2, -D/2 - tabH], size: [tabW, tabH] });
                        try { plate = plate.unite(fl).unite(fr).unite(bl).unite(br); } catch(e) {}
                    } else {
                        const f_center = new paper.Path.Rectangle({ point: [-tabW/2, D/2], size: [tabW, tabH] });
                        const b_center = new paper.Path.Rectangle({ point: [-tabW/2, -D/2 - tabH], size: [tabW, tabH] });
                        try { plate = plate.unite(f_center).unite(b_center); } catch(e) {}
                    }

                    // 2. å·¦å³ä¸¤ä¾§çš„å¯çœ¼å­”æ´ (ä¸ä¾§æ¿è¿æ¥) -> å­”æ´å˜å° (-kerf)
                    const holeW = T - kerf;
                    const holeH = sideTenonWidth - kerf;
                    const left_hole = new paper.Path.Rectangle({ point: [-innerXSpacing/2 - holeW/2, -holeH/2], size: [holeW, holeH] });
                    const right_hole = new paper.Path.Rectangle({ point: [innerXSpacing/2 - holeW/2, -holeH/2], size: [holeW, holeH] });
                    try {
                        plate = plate.subtract(left_hole).subtract(right_hole);
                    } catch(e) {}
                    return plate;
                }
                const bottomPlate = createBottomPlate();

                // æ¸…æ´—è·¯å¾„ï¼šå»é™¤å†—ä½™é¡¶ç‚¹ã€é‡ç»„æ‹“æ‰‘ï¼Œä¾› 3D æ‹‰ä¼¸å‡å°‘ä¸‰è§’å‰–åˆ†å¤±è´¥ï¼ˆåŸç”Ÿæ”¯æŒå­”æ´ï¼‰
                function cleanPathFor3D(path) {
                    if (!path) return null;
                    var eps = 0.08;
                    try {
                        // CompoundPathï¼šä¿ç•™æ‰€æœ‰å­è·¯å¾„ï¼ˆå¤–è½®å»“ + å­”æ´ï¼‰ï¼Œé€æ¡æ¸…æ´—
                        if (path.children && path.children.length > 0) {
                            var compound = new paper.CompoundPath();
                            for (var c = 0; c < path.children.length; c++) {
                                var child = path.children[c];
                                var segs = child.segments;
                                if (!segs || segs.length < 2) continue;
                                var points = [];
                                for (var i = 0; i < segs.length; i++) {
                                    var p = segs[i].point;
                                    if (points.length === 0 || p.getDistance(points[points.length - 1]) > eps)
                                        points.push(p.clone());
                                }
                                if (child.closed && points.length > 1)
                                    points.push(points[0].clone());
                                var subPath = new paper.Path(points);
                                if (child.closed) subPath.closePath();
                                compound.addChild(subPath);
                            }
                            return compound.children.length > 0 ? compound : path.clone();
                        }
                        // å•ä¸€è·¯å¾„
                        var segs = path.segments;
                        if (!segs || segs.length < 2) return path.clone();
                        var points = [];
                        for (var i = 0; i < segs.length; i++) {
                            var p = segs[i].point;
                            if (points.length === 0 || p.getDistance(points[points.length - 1]) > eps)
                                points.push(p.clone());
                        }
                        if (path.closed && points.length > 1)
                            points.push(points[0].clone());
                        var newPath = new paper.Path(points);
                        if (path.closed) newPath.closePath();
                        return newPath;
                    } catch (e) {
                        return path.clone();
                    }
                }

                // ä¾› 3D ä½¿ç”¨ï¼ˆä½¿ç”¨æ¸…æ´—åçš„è·¯å¾„ï¼‰
                computedParts.front = cleanPathFor3D(frontPanel); if (computedParts.front) centerPath(computedParts.front);
                computedParts.back = cleanPathFor3D(backPanel); if (computedParts.back) centerPath(computedParts.back);
                computedParts.sideL = cleanPathFor3D(leftSide); if (computedParts.sideL) centerPath(computedParts.sideL);
                computedParts.sideR = cleanPathFor3D(rightSide); if (computedParts.sideR) centerPath(computedParts.sideR);
                computedParts.bottom = cleanPathFor3D(bottomPlate); if (computedParts.bottom) centerPath(computedParts.bottom);

                // 5. å°†ç”Ÿæˆçš„é›¶ä»¶æ’ç‰ˆåˆ°å±å¹•ä¸Šå¯è§çš„ä½ç½®
                const drawItem = (item, x, y, title) => {
                    item.strokeColor = '#ef4444'; // çº¢è‰²åˆ‡å‰²çº¿
                    item.strokeWidth = 1;
                    item.fillColor = null;
                    item.bounds.topLeft = new paper.Point(x * scale, y * scale);
                    paper.project.activeLayer.addChild(item);
                    
                    new paper.PointText({
                        point: [x * scale + item.bounds.width/2, y * scale - 10],
                        content: title, fillColor: '#4b5563', fontSize: 14, fontWeight: 'bold', justification: 'center'
                    });
                };
                
                const drawMarkers = (markers, refPanel, refX, refY) => {
                    markers.forEach(m => { 
                        m.bounds.center = new paper.Point(
                            refPanel.bounds.center.x + m.position.x * scale, 
                            refPanel.bounds.center.y + m.position.y * scale
                        );
                        paper.project.activeLayer.addChild(m); 
                    });
                };

                let currentY = 30;
                // ä¿å­˜ç”¨äºå¯¼å‡ºçš„é¢æ¿å…‹éš†ï¼ˆ1 å•ä½ = 1mmï¼Œæ—  scale ä¸æ’ç‰ˆåç§»ï¼‰
                window.exportPanels = {
                    front: frontPanel.clone(),
                    back: backPanel.clone(),
                    left: leftSide.clone(),
                    right: rightSide.clone(),
                    bottom: bottomPlate.clone()
                };
                drawItem(frontPanel, 20, currentY, 'æ­£é¢ç«‹é¢');
                drawMarkers(blueMarkers, frontPanel, 20, currentY);
                drawItem(backPanel, 40 + W, currentY, 'èƒŒé¢ç«‹é¢');

                currentY += Math.max(H, 100) + 40;
                drawItem(leftSide, 20, currentY, 'å·¦ä¾§æ¿');
                drawItem(rightSide, 40 + D + T*2, currentY, 'å³ä¾§æ¿');
                drawItem(bottomPlate, 60 + D*2 + T*4, currentY, 'å¤§åº•æ¿');

                paper.view.draw();
                if (typeof update3DModel === 'function') update3DModel();

            } catch (err) {
                console.error("æ¸²æŸ“é‡åˆ°é”™è¯¯:", err);
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                try {
                    new paper.PointText({ 
                        point: paper.view.center, 
                        content: 'æ¸²æŸ“é”™è¯¯: ' + err.message, 
                        fillColor: '#ef4444', 
                        fontSize: 16, 
                        justification: 'center' 
                    });
                    paper.view.draw();
                } catch (e) {
                    console.error('æ— æ³•æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯:', e);
                }
            }
        }

        // ã€æè´¨å¼•æ“ã€‘æ¤´æœ¨ PBR + å•ä¾‹æè´¨ä¸ç‰ˆæœ¬é”ï¼Œæ¶ˆé™¤å¼‚æ­¥é‡å½±
        let materialTextureLoader = null;
        function getTextureLoader() {
            if (typeof THREE === 'undefined') return null;
            if (!materialTextureLoader) materialTextureLoader = new THREE.TextureLoader();
            return materialTextureLoader;
        }
        function getMaterial(type) {
            const commonSettings = {
                side: THREE.DoubleSide, depthWrite: true, depthTest: true,
                polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
            };
            switch (type) {
                case 'wood':
                    if (!woodMaterialInstance) {
                        woodMaterialInstance = new THREE.MeshStandardMaterial({
                            color: 0xffffff, // çº¯ç™½åº•è‰²ï¼Œä¸å¹²æ‰°è´´å›¾æœ¬èº«é¢œè‰²
                            roughness: 0.85, 
                            metalness: 0.1, 
                            ...commonSettings
                        });
                        const loader = getTextureLoader();
                        if (loader) {
                            loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/hardwood2_diffuse.jpg', (tex) => {
                                tex.wrapS = THREE.RepeatWrapping;
                                tex.wrapT = THREE.RepeatWrapping;
                                // è°ƒæ•´ä¸ºé€‚åˆæ•´ä¸ªæ±‰å­—å®½åº¦çš„é‡å¤ç‡
                                tex.repeat.set(0.008, 0.008); 
                                woodMaterialInstance.map = tex;
                                woodMaterialInstance.needsUpdate = true;
                                if (window.scene3D && window.scene3D.renderer) {
                                    window.scene3D.renderer.render(window.scene3D.scene, window.scene3D.camera);
                                }
                            }, undefined, (err) => {
                                console.warn('æœ¨çº¹è´´å›¾åŠ è½½å¤±è´¥', err);
                                // å¦‚æœåŠ è½½å¤±è´¥ï¼Œå›é€€åˆ°ç»å…¸çš„æ·±è‰²åŸæœ¨è‰²
                                woodMaterialInstance.color.setHex(0x8B5A2B); 
                                woodMaterialInstance.needsUpdate = true;
                            });
                        }
                    }
                    return woodMaterialInstance;
                case 'acrylic':
                    return new THREE.MeshStandardMaterial({ 
                        color: 0xcc0000,       // é²œè‰³çš„çº¢è‰²
                        roughness: 0.05,       // æä½ç²—ç³™åº¦ï¼Œäº§ç”Ÿé”åˆ©é«˜å…‰
                        metalness: 0.1,        // è½»å¾®é‡‘å±æ„Ÿå¢åŠ å¡‘æ–™çš„åå…‰åšé‡åº¦
                        transparent: true,     // å¼€å¯é€æ˜
                        opacity: 0.85,         // è®¾ç½®ä¸ºåŠé€æ˜
                        ...commonSettings 
                    });
                case 'metal':
                    return new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.35, metalness: 0.85, ...commonSettings });
                case 'default':
                default:
                    return new THREE.MeshLambertMaterial({ color: 0xffffff, ...commonSettings });
            }
        }

        // åˆå§‹åŒ– 3D åœºæ™¯ï¼ˆThree.jsï¼‰
        function init3D() {
            if (typeof THREE === 'undefined') return;
            const container = document.getElementById('threeContainer');
            if (!container) return;
            const width = container.clientWidth || 800;
            const height = container.clientHeight || 600;
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf3f4f6);
            const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 5000);
            camera.position.set(200, 150, 250);
            camera.lookAt(0, 0, 0);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            container.innerHTML = '';
            container.appendChild(renderer.domElement);
            const main3DGroup = new THREE.Group();
            scene.add(main3DGroup);
            // ã€å†·æš–åŒæ‰“å…‰ã€‘é…åˆ Phong æè´¨ï¼Œæ— ç¯å¢ƒè´´å›¾ä¹Ÿèƒ½å±‚æ¬¡åˆ†æ˜
            const ambient = new THREE.AmbientLight(0xffffff, 0.28);
            scene.add(ambient);
            const warmLight = new THREE.DirectionalLight(0xffdd99, 0.75);
            warmLight.position.set(120, 180, 120);
            scene.add(warmLight);
            const coolLight = new THREE.DirectionalLight(0xaaccff, 0.5);
            coolLight.position.set(-100, 100, -120);
            scene.add(coolLight);
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            const view3DContainer = document.getElementById('view3DContainer');
            window.scene3D = { scene, camera, renderer, controls, main3DGroup, container, view3DContainer };
            window.addEventListener('resize', function() {
                const c = document.getElementById('threeContainer');
                if (!c || !window.scene3D) return;
                const w = c.clientWidth;
                const h = c.clientHeight;
                window.scene3D.camera.aspect = w / h;
                window.scene3D.camera.updateProjectionMatrix();
                window.scene3D.renderer.setSize(w, h);
            });
            // å•ä¸€åŠ¨ç”»å¾ªç¯ï¼Œä»…å½“ 3D è§†å›¾å¯è§æ—¶æ¸²æŸ“ï¼Œé¿å…é‡å¤è§¦å‘
            (function animate3D() {
                requestAnimationFrame(animate3D);
                if (window.scene3D && window.scene3D.view3DContainer && !window.scene3D.view3DContainer.classList.contains('hidden') && window.scene3D.controls) {
                    window.scene3D.controls.update();
                    window.scene3D.renderer.render(window.scene3D.scene, window.scene3D.camera);
                }
            })();
        }

        // Paper.js è·¯å¾„ â†’ SVG å­—ç¬¦ä¸²ï¼ˆä¾› SVGLoader è§£æï¼‰
        function paperPathToSVGString(paperPath) {
            if (!paperPath) return '';
            try {
                const el = paperPath.exportSVG();
                const svgNs = 'http://www.w3.org/2000/svg';
                const svg = document.createElementNS(svgNs, 'svg');
                svg.setAttribute('xmlns', svgNs);
                const b = paperPath.bounds;
                svg.setAttribute('viewBox', [b.left, b.top, b.width, b.height].join(' '));
                if (el) svg.appendChild(el);
                return new XMLSerializer().serializeToString(svg);
            } catch (e) {
                console.warn('paperPathToSVGString failed:', e);
                return '';
            }
        }

        // ä½¿ç”¨ SVGLoader è§£æ SVG å¹¶æ‹‰ä¼¸ä¸ºç™½æ¨¡+é»‘çº¿æ¡†ï¼ˆæ”¯æŒè´å¡å°”ä¸é•‚ç©º CompoundPathï¼‰
        function paperPathToMesh(paperPath, depth, done) {
            if (typeof THREE === 'undefined' || !paperPath) {
                if (done) done(null);
                return;
            }
            const svgString = paperPathToSVGString(paperPath);
            if (!svgString) {
                if (done) done(null);
                return;
            }
            const loader = new THREE.SVGLoader();
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            loader.load(url, function(data) {
                URL.revokeObjectURL(url);
                const group = new THREE.Group();
                const currentMat = getMaterial(selectedMaterialType);
                if (data.paths && data.paths.length) {
                    data.paths.forEach(function(shapePath) {
                        try {
                            const shapes = THREE.SVGLoader.createShapes(shapePath);
                            const shapeArray = Array.isArray(shapes) ? shapes : (shapes ? [shapes] : []);
                            shapeArray.forEach(function(shape) {
                                const geometry = new THREE.ExtrudeGeometry(shape, { depth: depth, bevelEnabled: false });
                                geometry.center();

                                geometry.scale(1, -1, 1);
                                geometry.computeVertexNormals();

                                const matToUse = (selectedMaterialType === 'acrylic' || selectedMaterialType === 'wood') ? currentMat : currentMat.clone();
                                const mesh = new THREE.Mesh(geometry, matToUse);

                                const edges = new THREE.EdgesGeometry(geometry, 15);
                                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({
                                    color: 0x333333,
                                    depthTest: true,
                                    depthWrite: true
                                }));
                                mesh.add(line);

                                group.add(mesh);
                            });
                        } catch (err) {
                            console.warn('SVGLoader createShapes/Extrude failed:', err);
                        }
                    });
                }
                if (done) done(group.children.length > 0 ? group : null);
            }, undefined, function(err) {
                URL.revokeObjectURL(url);
                console.warn('SVGLoader load failed:', err);
                if (done) done(null);
            });
        }

        // æ›´æ–°3Dæ¨¡å‹ï¼ˆThree.js ç»„è£…ï¼ŒSVGLoader å¼‚æ­¥åŠ è½½ + ç‰ˆæœ¬é”é˜²é‡å ï¼‰
        function update3DModel() {
            if (typeof THREE === 'undefined' || !window.scene3D || !window.scene3D.main3DGroup) return;
            if (!computedParts.front || !computedParts.back) return;
            if (!computedParts.sideL || !computedParts.sideR || !computedParts.bottom) return;

            renderGeneration++;
            const currentGen = renderGeneration;

            const main3DGroup = window.scene3D.main3DGroup;
            while (main3DGroup.children.length) main3DGroup.remove(main3DGroup.children[0]);

            const results = {};
            let pending = 5;

            function tryAssemble() {
                if (currentGen !== renderGeneration) return;

                pending--;
                if (pending !== 0) return;

                const { front: frontMesh, back: backMesh, sideL: sideLMesh, sideR: sideRMesh, bottom: bottomMesh } = results;
                if (!frontMesh || !backMesh || !sideLMesh || !sideRMesh || !bottomMesh) return;

                const bY = innerYSpacing / 2;
                const lX = -innerXSpacing / 2 + offsetX;
                const rX = innerXSpacing / 2 + offsetX;

                frontMesh.position.set(0, 0, D / 2 + T / 2); main3DGroup.add(frontMesh);
                backMesh.position.set(0, 0, -D / 2 - T / 2); backMesh.rotation.y = Math.PI; main3DGroup.add(backMesh);
                bottomMesh.rotation.x = Math.PI / 2; bottomMesh.position.set(offsetX, -bY, 0); main3DGroup.add(bottomMesh);
                sideLMesh.rotation.y = Math.PI / 2; sideLMesh.position.set(lX, -bY + sidePanelHeight / 2 + T / 2, 0); main3DGroup.add(sideLMesh);
                sideRMesh.rotation.y = Math.PI / 2; sideRMesh.position.set(rX, -bY + sidePanelHeight / 2 + T / 2, 0); main3DGroup.add(sideRMesh);

                main3DGroup.position.y = offsetY;
                if (window.scene3D.controls) window.scene3D.controls.update();
                if (window.scene3D.renderer) window.scene3D.renderer.render(window.scene3D.scene, window.scene3D.camera);
            }

            paperPathToMesh(computedParts.front, T, function(m) { results.front = m; tryAssemble(); });
            paperPathToMesh(computedParts.back, T, function(m) { results.back = m; tryAssemble(); });
            paperPathToMesh(computedParts.sideL, T, function(m) { results.sideL = m; tryAssemble(); });
            paperPathToMesh(computedParts.sideR, T, function(m) { results.sideR = m; tryAssemble(); });
            paperPathToMesh(computedParts.bottom, T, function(m) { results.bottom = m; tryAssemble(); });
        }

        // åˆå§‹åŒ–å·²é€šè¿‡ checkAllLoaded() å‡½æ•°è‡ªåŠ¨è§¦å‘
        // å¦‚æœåŠ¨æ€åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ£€æŸ¥
        setTimeout(() => {
            if (typeof paper === 'undefined' || typeof opentype === 'undefined') {
                waitForLibraries(() => {
                    initializeApp();
                    setTimeout(() => {
                        if (typeof paper !== 'undefined') {
                            render();
                        }
                    }, 150);
                });
            }
        }, 2000);
    </script>
</body>
</html>